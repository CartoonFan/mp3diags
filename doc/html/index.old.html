<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="keywords" content="MP3, diags, diagnosis, tag editor, tagger, normalizer" />
<meta name="description" content="End-user documentation for MP3 Diags, an MP3 analysis tool that also includes correction and tag editing functionality" />
<title>MP3 Diags</title>


<link rel="stylesheet" type="text/css" media="screen" href="style.css">

<!--

changing the font size for .Code:
from medium to 13px - just increases width

-->


<!--
===============================================================================================================================================
Current sizes for most browsers, including IE7, using small/medium/large/ ... fonts. Looks huge on IE6, though, so there's a workaround next
===============================================================================================================================================
-->


<style type="text/css">
<!--



-->
</style>

<!--
font-weight: bold; 

.InlineCode     { color: #0000b0; font-style: italic; font-family: 'Courier New'; }
.InlineCode     { color: #0000b0; font-family: 'Courier New'; font-size: large; }

-->




<!-- ttt0
===============================================================================================================================================
Workaround for IE6 (and perhaps earlier); all font sizes are smaller than for the other browsers in order to have a similar appearance.
===============================================================================================================================================
-->


<!--[if lt IE 7 ]>

<style type="text/css">

.Code           { font-size: x-small; }

.SmalllText     { font-size: x-small; }
.NormalText     { font-size: small; }
.SubChapterText { font-size: medium; }
.ChapterText    { font-size: large; }
.TitleText      { font-size: x-large; }
.InclSubChapterText { font-size: medium;  }

</style>

<![endif]-->









<!--
===============================================================================================================================================
                        Original, fixed-size, fonts; Look OK in FF and IE6 but don't allow resizing in IE6
===============================================================================================================================================
-->


<!--

.Code           { font-family: 'Courier New', 'Lucida Console', 'Andale Mono', 'B&H Lucida Typewriter', 'Lucida Sans Typewriter', Courier, Monospace; font-size: 12px; line-height: 12px;  }

.RegFnt         { font-family:  Arial, Verdana, Helvetica, sans-serif; }

.Comment        { color: #57628a; font-style: italic; }
.Preproc        { color: #006633; }
.Keyword        { font-weight: bold; color: #000000; }
.Integer        { color: #0000ff; }
.Regular        { color: #000000; }
.StdType        { font-weight: bold; color: #800000; }
.StringVal      { color: #dd0000; }
.StringSpecChar { color: #ff00ff; }
.Double         { color: #800080; }

.Hlt { background: yellow; font-weight: bold; }


.ChpCol1 { background: #ececec; }
.ChpCol2 { background: #f8f8f8; }


.NormalText     { color: #000000; font-size: 14px; padding-bottom: 10px; padding-left: 8px; padding-right: 8px; }
.SubChapterText { color: #000000; font-weight: bold; font-size: 16px; padding-bottom: 10px; padding-top: 15px; padding-left: 18px; padding-right: 8px; }
.ChapterText    { color: #000000; font-weight: bold; font-size: 20px; padding-bottom: 12px; padding-top: 18px; padding-left: 28px; padding-right: 8px; }
.TitleText      { color: #000000; font-weight: bold; font-size: 26px; padding-bottom: 15px; text-align: center; }

.ListLev1  { list-style: disc; }
.ListLev2  { list-style: circle; }

.ListSpace { padding-bottom: 4px; padding-top: 4px; }


-->









</head>
<body>

<!--
word-spacing: 30px;
border: 5px solid red;

p { padding-top: -8px; }


<b><i>mkF</i></b>   - for "inline code"

<span style="text-align: center;"></span>

-->


<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->



<div class="NormalText RegFnt ChpCol2" >


<table width=100% border="0" cellpadding="5" cellspacing="2" class="TitleText RegFnt">
    <tr>
        <td border="0" class="TitleText">
            <a href="index.html"> <img src="logo.png" border="0" alt="MP3 Diags" /> </a>
        </td>
        <td border="0" class="RightAlign">
            Hosted by SF
        </td>
    </tr>
</table>

</div>


<!--
            <table>
                <tr>
                    <td border="2" class="NormalText ChpCol2">
                        Hosted by
                    </td>
                    <td border="2" class="NormalText ChpCol2">
                        qq ve rt trvgertv trv tr rtb rtbh
                    </td>
                </tr>
            </table>
-->

                        <!-- <a href="http://sourceforge.net"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=203477&amp;type=5" width="210" height="62" border="0" alt="SourceForge.net Logo" /></a> -->


<!--
<div class="ChapterText RegFnt ChpCol1" style="text-align: left;">
</div>
-->





<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->




<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->


<div class="ChapterText RegFnt ChpCol1" >
Motivation
</div>


<div class="NormalText RegFnt ChpCol1" >
There are many programs that create and edit MP3 files, and many of them are broken. As a result, many MP3 files have various issues, ranging from values that are not standards-conforming but that are tolerated by all players and tools (so they look perfectly fine to the end user) to files that play correctly only on some players or even cause players and tools to crash. Many of the tools are quite tolerant of errors in an MP3 file, but some are less so. Also, there are reasons to change a file even if it technically doesn't have errors; for example you may want to add the image on album cover, or the lyrics.
</div>


<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->



<div class="ChapterText RegFnt ChpCol2" >
What is MP3 Diags and what does it do?
</div>


<div class="NormalText RegFnt ChpCol2" >
In a few words, MP3 Diags is a GUI-based application that allows end-users to identify issues with their MP3 files, fix some of the issues and make other changes to MP3 files, including adding track information and album cover art.
</div>

<div class="NormalText RegFnt ChpCol2" >
Unlike some programs that are designed to deal with a single topic (like fixing VBR headers or adding cover art), MP3 Diags is a one stop solution that identifies more than 50 different issues in MP3 files and provides the means to fix many of them (well, not everything is fixable; you can't make a 64kbps file sound like a 256kbps one.)
</div>

<div class="NormalText RegFnt ChpCol2" >
Some of the more important issues that are found:
<ul class="ListLev1">
    <li> incorrect placement of tags/headers (ID3V2, ID3V1, Lame, Xing, ...) </li>
    <li> broken tags / headers / audio </li>
    <li> duplicate tags / headers </li>
    <li> low quality audio </li>
    <li> missing VBR header </li>
    <li> missing track info / cover art </li>
    <li> broken track info / cover art </li>
    <li> missing normalization data </li>
    <li> character encoding issues (for languages other than English) </li>
</ul>

</div>

<div class="NormalText RegFnt ChpCol2" >

</div>




<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->



<div class="NormalText RegFnt ChpCol2" >
<br/><br/>
<span class="ChapterText RegFnt ChpCol2"> Content </span>

<ul class="ListLev1">
    <li> <a href="#Origin"> Origin and acknowledgements </a> </li>
    <ul class="ListLev1">
        <li> <a href="#Highlights"> Highlights </a> </li>
    </ul>
    <li> <a href="#WhyUse"> Why use QuickFunctor? </a> </li>
    <li> <a href="#Install"> Installation and testing </a> </li>
    <li> <a href="#Developing"> Developing code that uses QuickFunctor </a> </li>
    <ul class="ListLev1">
        <li> <a href="#UsageSample"> An example using functors </a> </li>
    </ul>
    <li> <a href="#Reference"> Reference </a> </li>
    <ul class="ListLev1">
        <li> <a href="#FctTypes"> Types of functors </a> </li>
        <li> <a href="#FctCreation"> Creating functors </a> </li>
        <li> <a href="#Operations"> Operations </a> </li>
        <ul class="ListLev1">
            <li> <a href="#OpComp"> <span class="NoBoldInlineCode">comp&lt;n&gt;(f)</span> </a> </li>
            <li> <a href="#OpDerefR"> <span class="NoBoldInlineCode">deref()</span> </a> </li>
            <li> <a href="#OpAddrR"> <span class="NoBoldInlineCode">addr()</span> </a> </li>
            <li> <a href="#OpDerefA"> <span class="NoBoldInlineCode">deref&lt;n&gt;()</span> </a> </li>
            <li> <a href="#OpAddrA"> <span class="NoBoldInlineCode">addr&lt;n&gt;()</span> </a> </li>
            <li> <a href="#OpBind"> <span class="NoBoldInlineCode">bind&lt;n&gt;(x)</span> </a> </li>
            <li> <a href="#OpDel"> <span class="NoBoldInlineCode">del&lt;r, m&gt;()</span> </a> </li>
            <li> <a href="#OpPerm"> <span class="NoBoldInlineCode">perm&lt;n1, n2&gt;()</span>, <span class="NoBoldInlineCode">Perm&lt;n1, n2, n3&gt;()</span>, ... </a> </li>
            <li> <a href="#OpCast"> <span class="NoBoldInlineCode">cast&lt;R&gt;()</span>, <span class="NoBoldInlineCode">cast&lt;R, P1&gt;()</span>, <span class="NoBoldInlineCode">cast&lt;R, P1, P2&gt;()</span>, ... </a> </li>
            <li> <a href="#OpO"> <span class="NoBoldInlineCode">o(f)</span> </a> </li>
        </ul>
        <li> <a href="#ArithmExpr"> Expressions (arithmetic, boolean, string) </a> </li>
        <li> <a href="#AlgUsage"> Usage with algorithms </a> </li>
        <li> <a href="#AsgnExpr"> Assignment expressions </a> </li>
        <li> <a href="#Casting"> Casting </a> </li>
        <li> <a href="#NullFct"> Null functors </a> </li>
        <li> <a href="#UserTypeExpr"> Expressions with a user type </a> </li>
        <li> <a href="#FindSig"> Finding the signature of a functor </a> </li>
        <li> <a href="#ErrorHndl"> Dealing with errors </a> </li>
    </ul>
    <li> <a href="#AboutCode"> About the code </a> </li>
    <li> <a href="#LookingAtCode"> Looking at the source code </a> </li>
    <li> <a href="#StdComparison"> A comparison to the standard </a> </li>
    <li> <a href="#BoostComparison"> A comparison to the Boost Library </a> </li>
    <li> <a href="#TR1Comparison"> A comparison to the TR1 Library </a> </li>
    <li> <a href="#Issues"> Issues and open items </a> </li>
    <li> <a href="#OtherNotes"> Other notes </a> </li>
    <li> <a href="#Status"> Project status </a> </li>
    <li> <a href="#ReleaseHistory"> Release history </a> </li>
    <li> <a href="#Support"> Contact and support </a> </li>
</ul>
</div>


<!--
    <li> <a href="#">  </a> </li>
-->



<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->


<a name="Origin"/>

<div class="ChapterText RegFnt ChpCol1" >
Origin and acknowledgements
</div>



<div class="NormalText RegFnt ChpCol1" >
After trying several times to use the functors from the standard library and getting frustrated that it took too long to figure out how to do things, and that some things that I thought were reasonable to do just couldn't be done (or at least I was unable to find a way to do them), and after taking a quick look at other functor implementations, I started to develop QuickFunctor, with the declared purpose to create a library that allows its users to do pretty much anything that is reasonable to do with functors, and do it as easily and as efficiently as possible.
</div>

<div class="NormalText RegFnt ChpCol1" >
Many "idea leaders" in the C++ community (Bjarne Stroustrup, Scott Meyers, Herb Sutter, Daveed Vandevoorde, Nicolai Josuttis among them) advocate using functors, and I find their arguments persuasive. The standard library provides an implementation for functors, in the &lt;functional&gt; header, but from my point of view it has some drawbacks and limitations, which were significant enough to make me decide to write my own QuickFunctor, which I think has several advantages:
</div>

<!--
<div class="SubChapterText RegFnt ChpCol1" >
Highlights
</div>
-->

<a name="Highlights"/>

<div class="NormalText RegFnt ChpCol2" style="padding-top: 15px;">
<!-- <ul type=disc> -->


<span class="InclSubChapterText RegFnt ChpCol2" >Highlights</span>
<ul class="ListLev1">
    <li class="ListSpace"> Functors can be combined in expressions (arithmetic, boolean, string, ...), using most C++ operators. Expressions of numerical and string types are handled directly, and user types can easily be accommodated, if needed, including numeric user types (like <span class="InlineCode">Fraction</span>) that can be combined in expressions with standard types (like <span class="InlineCode">int</span>). </li>

    <li class="ListSpace"> Constructors for functors take a more diverse set of parameters. Besides being able to create a functor from a member or a global function, a functor can be created from a value or from a local, static or member variable. </li>
    <li class="ListSpace"> It can create functors from function members that have parameters. </li>
    <li class="ListSpace"> It can deal with functors with 3 or more parameters. </li>
    <li class="ListSpace"> A more consistent naming scheme. If you want to create a functor from a function, it doesn't matter if the function takes a parameter, two, or none, if it's a member function or a global one, if it takes references or pointers. There is one (highly) overloaded function called <span class="InlineCode">mkF</span> (for "make functor"), which detects what parameter is passed and generates the appropriate functor. (But when constructing a functor from a variable there are more options, described below.) </li>
    <li class="ListSpace"> An extensive set of operations that can be applied to existing functors to create new functors. These include:
        <ul class="ListLev2">
            <li> mathematical composition, including an extension that works with functors with more than 1 parameter </li>
            <li> result and parameter conversion between references and pointers </li>
            <li> binding of parameters (like STL's <span class="InlineCode">bind1st</span> and <span class="InlineCode">bind2nd</span>) </li>
            <li> removal / substitution of parameters </li>
            <li> permutations </li>
            <li> casting </li>
        </ul>
    </li>
    <li class="ListSpace"> Regardless of how are they built, functors can be stored in variables with simple types (which are called "named functors"), if there's a need. However, using such a functor takes more memory (including heap memory, while unnamed functors usually just use the stack) and involves virtual function calls. (Actually this is the only place where virtual functions are used.) </li>
</ul>

While the code of QuickFunctor is entirely new, it should be quite easy to notice that it is highly influenced by the interface of Alexander Stepanov's STL library and by Andrei Alexandrescu's "Modern C++ Design" book.
</div>





<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->




<a name="WhyUse"/>

<div class="ChapterText RegFnt ChpCol1" >
Why use QuickFunctor?
</div>


<div class="NormalText RegFnt ChpCol1" >
Here are some reasons to use functors from QuickFunctor:

<ul class="ListLev1">

    <li class="ListSpace"> They can be passed to STL algorithms (like <span class="InlineCode">for_each</span>, <span class="InlineCode">find_if</span>, ...), just like the ones provided by the standard library, while having the advantages described above (diversity, number of arguments, naming, operations, expressions and named functors) </li>
    <li class="ListSpace"> If named functors aren't used, there is no virtual method call made, ho heap memory use and the compiler can perform many optimizations. </li>
    <li class="ListSpace"> They can be used to represent the concept of a computed value without creating a function. I realized that named functors can simplify things, by providing the functionality of a "generalized pointer to a function" while no actual function has to be defined. </li>
    <li class="ListSpace"> They are free for both private and business use. While the code is released under the <a href="http://www.opensource.org/licenses/mit-license.php">MIT license</a> (X11 License), I'm willing to put it into the public domain, if I can figure out how to do it and if there are requests for doing it. </li>
    <li class="ListSpace"> In a sense the "<a href="#AsgnExpr">assignment expressions</a>" allow something resembling self-modifiable code. Functors represent "chunks of code", which can be manipulated and passed on, as parameters to other functions or kept as variables. This may lead to some new coding styles.</li>
    <li class="ListSpace"> They offer a pretty clean solution for associating "handlers" to events in a graphical framework or a similar event-driven environment. (Actually I have something better for that, but it's not ready to be released.) </li>
</ul>



</div>



<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->

<a name="Install"/>

<div class="ChapterText RegFnt ChpCol2" >
Installation and testing
</div>


<div class="NormalText RegFnt ChpCol2" >
<a href="http://sourceforge.net/project/showfiles.php?group_id=203477">Download</a> and unpack QuickFunctor and then modify the "<span class="Hlt">additional include directories</span>" in your IDE to add the directory <span class="FileName">include</span> from wherever you unpacked QuickFunctor. Or move the directory somewhere else and specify that new place. The <span class="FileName">include</span> directory is the only one you really need. The others are examples, documentation, ... Or, if you use a command line compiler, keep in mind to pass it the location of the <span class="FileName">include</span> directory when you try to compile something.
</div>

<div class="NormalText RegFnt ChpCol2" >
To check that it works, you <span class="Hlt">should be able to create an executable</span> file from the source files in the <span class="FileName">main_tests</span> directory (<span class="FileName">FunctorTst.cpp</span> and <span class="FileName">main.cpp</span>) and from <span class="FileName">other_tests</span> (<span class="FileName">Functor.cpp</span>, <span class="FileName">FunctorExpressionsTst.cpp</span> and <span class="FileName">NumericCommonTypesTst.cpp</span>). <span class="Hlt">If you can't create the executable, there's no point in going further. You need to change or upgrade your compiler</span> (well, or you can try to make changes in the library, to accommodate your compiler, but that's not going to be easy). That executable should produce an output similar to those in the directory <span class="FileName">results</span> (keeping in mind that the order in which those tests are run is undetermined; so if you want to capture the output and do a comparison you might need to move things around in a text editor).
</div>

<div class="NormalText RegFnt ChpCol2" >
If you have Eclipse with CDT, you might try to import the included Eclipse project, in the root directory. I'm not sure if it's supposed to work, especially if you have a different version of Eclipse or CDT, but it may be worth giving it a try.
</div>




<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->

<a name="Developing"/>

<div class="ChapterText RegFnt ChpCol1" >
Developing code that uses QuickFunctor
</div>

<div class="NormalText RegFnt ChpCol1" >
First of all, you need to <a href="#Install">install it</a> and you need a pretty new compiler. Old compilers are quite likely to be unable to deal with QuickFunctor. Here's what I currently know (as of 23 August 2007):
<ul class="ListLev1">
    <li> It was developed with GCC 4.1.0 (dated 20060429), on openSUSE 10.1, 64-bit, so it obviously works there. </li>
    <li> A test was run on GCC 4.1.1 20070105 on RHEL5, which succeeded. </li>
    <li> A test was run on MSVC 2005 on Windows XP SP2, which failed. </li>
    <li> A test was run on MSVC 2005 <span class="Hlt">SP1</span> on Windows XP SP2, which succeeded after making some code changes (which were kept, so it should work there too). </li>
    <li> A test was run on GCC 4.2.1 (dated 20070724) on openSUSE 10.2, 64-bit, which succeeded. </li>
</ul>
</div>

<div class="NormalText RegFnt ChpCol1" >
Please let me know if it works (or not) on your (different) system. Attaching the output of the test programs would be nice too. (See the e-mail address at the end of the file.)
</div>

<div class="NormalText RegFnt ChpCol1" >
Also, remember that everything is in the <span class="Hlt"><span class="InlineCode">pearl</span></span> namespace.
</div>


<div class="NormalText RegFnt ChpCol1" >
I would suggest this strategy for getting started with QuickFunctor:
<ul class="ListLev1">
    <li> Take a short look at the next example. </li>
    <li> Gloss over the <a href="#Reference">reference</a>. </li>
    <li> Come back to this example and try to fully understand it, going back to the reference as needed. </li>
    <li> Read more carefully the whole reference section, to better familiarize yourself with the features of QuickFunctor. </li>
    <li> Start writing your own code, looking at similar examples in the reference; or perhaps you can start by modifying the examples. </li>
</ul>

</div>


<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->


<a name="UsageSample"/>

<div class="SubChapterText RegFnt ChpCol2" >
An example using functors
</div>

<div class="NormalText RegFnt ChpCol2" >
Here's an example of what can be done with these functors. It's about a vector of cars and searching through it. I hope it's quite self-evident, but here are a few things worth noticing:

<ul class="ListLev1">
    <li class="ListSpace"> The function <span class="InlineCode">findCars()</span> takes a <span class="InlineCode">const Functor&lt;bool (Car&amp;)&gt;&amp;</span> parameter, which means functors that have a <span class="InlineCode"><span class="Hlt">bool operator()(Car&amp;) const;</span></span> they check a condition for the car. </li>

    <li class="ListSpace"> Expressions are used everywhere: <span class="InlineCode">mkF(&amp;Car::mpg) &gt;= 23</span> applies the operator <span class="InlineCode">&gt;=</span> between a functor created with <span class="InlineCode">mkF(&amp;Car::mpg)</span> and the integer literal <span class="InlineCode">23</span>. Further down, more complex expressions occur, containing also the operator <span class="InlineCode">&amp;&amp;</span> to combine two tests. </li>

    <li class="ListSpace"> <span class="InlineCode">mkF(hasTdi).comp&lt;1&gt;(mkF(&amp;Car::model))</span> uses composition, to pass the model of a car to a standalone function taking a string; this rather complex expression is a functor that has the required signature (<span class="Signature">&lt;bool (Car&amp;)&gt;</span>), while <span class="InlineCode">hasTdi()</span> has nothing to do with <span class="InlineCode">Car&amp;</span> </li>

    <li class="ListSpace"> In order to use only <span class="InlineCode">mkF</span>, the type of the functor passed to <span class="InlineCode">findCars()</span> was chosen to be <span class="InlineCode">const Functor&lt;bool (Car&amp;)&gt;&amp;</span>. It would make more sense to be <span class="InlineCode">const Functor&lt;bool (<span class="Hlt">const</span> Car&amp;)&gt;&amp;</span>, since testing a car isn't supposed to also change it. It's quite easy to make the change, by replacing the type in <span class="InlineCode">findCars()</span>' second argument and by using <span class="InlineCode">mkFC</span>. Also, <span class="InlineCode">mkFCR(&amp;Car::make)</span> should be used rather than <span class="InlineCode">mkF(&amp;Car::make)</span>, so the parameter is passed as a reference and not as a value (<span class="InlineCode">const string&amp;</span> instead of <span class="InlineCode">string</span>). But this is just for efficiency reasons, otherwise both versions would work the same. </li>

</ul>

This example is meant to be looked at, but it's probably a good idea to compile it too; you may want to check the <a href="#Install">installation</a> section above. You'll have to download and unpack QuickFunctor, copy this example code to a .cpp file and compile that file, making sure that you pass to the compiler the <span class="FileName">include</span> directory from where you unpacked QuickFunctor. With GCC it's the -I option. Various IDEs and compilers have their own ways of specifying where the "additional include directories" are. (The file <span class="FileName">main_tests/FunctorTst.cpp</span> has a slightly modified version of this example.)

<!--

To keep code lines closer:

style="font-size: 1px"


-->

<table border="0" cellpadding="5" cellspacing="2"> <tr> <td/> <td> <table border="0.5" bordercolor="#000000" cellpadding="5" cellspacing="0"> <tr> <td border="2" bgcolor="#ffffe0" bordercolor="#000000" style="font-size: 10px">

<pre><span class="Preproc Code">#include &lt;iostream&gt;</span>
<span class="Preproc Code">#include &lt;vector&gt;</span>
<span class="Preproc Code">#include &lt;algorithm&gt;</span>
<span class="Preproc Code">#include &lt;string&gt;</span>

<span class="Preproc Code">#include &lt;FullFunctor.h&gt;</span>

<span class="Keyword Code">using</span><span class="Regular Code"> </span><span class="Keyword Code">namespace</span><span class="Regular Code"> std;</span>
<span class="Keyword Code">using</span><span class="Regular Code"> </span><span class="Keyword Code">namespace</span><span class="Regular Code"> pearl;</span>

<span class="Keyword Code">struct</span><span class="Regular Code"> Car</span>
<span class="Regular Code">{</span>
<span class="Regular Code">    string make;</span>
<span class="Regular Code">    string model;</span>
<span class="Regular Code">    </span><span class="StdType Code">int</span><span class="Regular Code"> mpg;</span>

<span class="Regular Code">    Car(</span><span class="StdType Code">const</span><span class="Regular Code"> string&amp; make, </span><span class="StdType Code">const</span><span class="Regular Code"> string&amp; model, </span><span class="StdType Code">int</span><span class="Regular Code"> mpg) : make(make), model(model), mpg(mpg) {}</span>
<span class="Regular Code">};</span>

<span class="Regular Code">ostream&amp; </span><span class="Keyword Code">operator</span><span class="Regular Code">&lt;&lt;(ostream&amp; out, </span><span class="StdType Code">const</span><span class="Regular Code"> Car&amp; car)</span>
<span class="Regular Code">{</span>
<span class="Regular Code">    out &lt;&lt; car.make &lt;&lt; </span><span class="StringVal Code">" "</span><span class="Regular Code"> &lt;&lt; car.model &lt;&lt; </span><span class="StringVal Code">" "</span><span class="Regular Code"> &lt;&lt; car.mpg;</span>
<span class="Regular Code">    </span><span class="Keyword Code">return</span><span class="Regular Code"> out;</span>
<span class="Regular Code">}</span>

<span class="Comment Code">// Finds the cars that satisfy some given condition and displays them.</span>
<span class="Comment Code">// To do so it moves them to the beginning of the vector.</span>
<span class="StdType Code">void</span><span class="Regular Code"> findCars(vector&lt;Car&gt;&amp; v, </span><span class="StdType Code"><span class="Hlt">const</span></span><span class="Regular Code"><span class="Hlt"> Functor&lt;</span></span><span class="StdType Code"><span class="Hlt">bool</span></span><span class="Regular Code"><span class="Hlt"> (Car&amp;)&gt;&amp; test</span>)</span>
<span class="Regular Code">{</span>
<span class="Regular Code">    vector&lt;Car&gt;::iterator it;</span>
<span class="Regular Code">    it = partition(v.begin(), v.end(), test);</span>

<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"found "</span><span class="Regular Code"> &lt;&lt; it - v.begin() &lt;&lt; </span><span class="StringVal Code">" result(s):</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">------------------</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>
<span class="Regular Code">    </span><span class="Keyword Code">for</span><span class="Regular Code"> (vector&lt;Car&gt;::iterator it1 = v.begin(); it1 != it; ++it1)</span>
<span class="Regular Code">    {</span>
<span class="Regular Code">        cout &lt;&lt; (*it1) &lt;&lt; endl;</span>
<span class="Regular Code">    }</span>
<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"**************************************</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>
<span class="Regular Code">}</span>

<span class="StdType Code">bool</span><span class="Regular Code"> hasTdi(</span><span class="StdType Code">const</span><span class="Regular Code"> string&amp; s)</span>
<span class="Regular Code">{</span>
<span class="Regular Code">    </span><span class="Keyword Code">return</span><span class="Regular Code"> string::npos != s.find_first_of(</span><span class="StringVal Code">"TDI"</span><span class="Regular Code">);</span>
<span class="Regular Code">}</span>

<span class="StdType Code">void</span><span class="Regular Code"> sampleUsage()</span>
<span class="Regular Code">{</span>
<span class="Regular Code">    vector&lt;Car&gt; v;</span>
<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"=========================== sampleUsage() ========================================</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>
<span class="Regular Code">    v.push_back(Car(</span><span class="StringVal Code">"Toyota"</span><span class="Regular Code">, </span><span class="StringVal Code">"Corolla"</span><span class="Regular Code">, </span><span class="Integer Code">29</span><span class="Regular Code">));</span>
<span class="Regular Code">    v.push_back(Car(</span><span class="StringVal Code">"VW"</span><span class="Regular Code">, </span><span class="StringVal Code">"Golf TDI"</span><span class="Regular Code">, </span><span class="Integer Code">41</span><span class="Regular Code">));</span>
<span class="Regular Code">    v.push_back(Car(</span><span class="StringVal Code">"Toyota"</span><span class="Regular Code">, </span><span class="StringVal Code">"Land Cruiser"</span><span class="Regular Code">, </span><span class="Integer Code">14</span><span class="Regular Code">));</span>
<span class="Regular Code">    v.push_back(Car(</span><span class="StringVal Code">"Toyota"</span><span class="Regular Code">, </span><span class="StringVal Code">"Avalon"</span><span class="Regular Code">, </span><span class="Integer Code">23</span><span class="Regular Code">));</span>
<span class="Regular Code">    v.push_back(Car(</span><span class="StringVal Code">"Toyota"</span><span class="Regular Code">, </span><span class="StringVal Code">"Prius"</span><span class="Regular Code">, </span><span class="Integer Code">48</span><span class="Regular Code">));</span>
<span class="Regular Code">    v.push_back(Car(</span><span class="StringVal Code">"VW"</span><span class="Regular Code">, </span><span class="StringVal Code">"Jetta"</span><span class="Regular Code">, </span><span class="Integer Code">32</span><span class="Regular Code">));</span>
<span class="Regular Code">    v.push_back(Car(</span><span class="StringVal Code">"Honda"</span><span class="Regular Code">, </span><span class="StringVal Code">"Accord V6"</span><span class="Regular Code">, </span><span class="Integer Code">24</span><span class="Regular Code">));</span>
<span class="Regular Code">    v.push_back(Car(</span><span class="StringVal Code">"Honda"</span><span class="Regular Code">, </span><span class="StringVal Code">"Accord V4"</span><span class="Regular Code">, </span><span class="Integer Code">27</span><span class="Regular Code">));</span>

<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"Cars that have at least 23 mpg</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>
<span class="Regular Code">    findCars(v, <span class="Hlt">mkF(&amp;Car::mpg)</span> &gt;= </span><span class="Integer Code">23</span><span class="Regular Code">);</span>

<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"Cars that have the mpg between 23 and 41</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>
<span class="Regular Code">    findCars(v, mkF(&amp;Car::mpg) <span class="Hlt">&gt;=</span> </span><span class="Integer Code">23</span><span class="Regular Code"> <span class="Hlt">&amp;&amp;</span> mkF(&amp;Car::mpg) &lt;= </span><span class="Integer Code">41</span><span class="Regular Code">);</span>

<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"Toyotas that have at least 25 mpg</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>
<span class="Regular Code">    findCars(v, mkF(&amp;Car::make) == </span><span class="StringVal Code">"Toyota"</span><span class="Regular Code"> &amp;&amp; mkF(&amp;Car::mpg) &gt;= </span><span class="Integer Code">25</span><span class="Regular Code">);</span>

<span class="Regular Code">    vector&lt;Car&gt;::iterator it;</span>
<span class="Regular Code">    it = find_if(v.begin(), v.end(), mkF(hasTdi).<span class="Hlt">comp&lt;</span></span><span class="Integer Code"><span class="Hlt">1</span></span><span class="Regular Code"><span class="Hlt">&gt;</span>(mkF(&amp;Car::model)));</span>
<span class="Regular Code">    </span><span class="Comment Code">//  mkF(hasTdi).o(mkF(&amp;Car::model)) is a shortcut for the test above</span>
<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"A car that has TDI: "</span><span class="Regular Code"> &lt;&lt; (*it) &lt;&lt; endl;</span>
<span class="Regular Code">}</span>

<span class="StdType Code">int</span><span class="Regular Code"> main()</span>
<span class="Regular Code">{</span>
<span class="Regular Code">    sampleUsage();</span>
<span class="Regular Code">}</span>


<span class="Comment Code">/*output:</span>
<span class="Comment Code">=========================== sampleUsage() ========================================</span>
<span class="Comment Code">Cars that have at least 23 mpg</span>
<span class="Comment Code">found 7 result(s):</span>
<span class="Comment Code">------------------</span>
<span class="Comment Code">Toyota Corolla 29</span>
<span class="Comment Code">VW Golf TDI 41</span>
<span class="Comment Code">Honda Accord V4 27</span>
<span class="Comment Code">Toyota Avalon 23</span>
<span class="Comment Code">Toyota Prius 48</span>
<span class="Comment Code">VW Jetta 32</span>
<span class="Comment Code">Honda Accord V6 24</span>
<span class="Comment Code">**************************************</span>
<span class="Comment Code">Cars that have the mpg between 23 and 41</span>
<span class="Comment Code">found 6 result(s):</span>
<span class="Comment Code">------------------</span>
<span class="Comment Code">Toyota Corolla 29</span>
<span class="Comment Code">VW Golf TDI 41</span>
<span class="Comment Code">Honda Accord V4 27</span>
<span class="Comment Code">Toyota Avalon 23</span>
<span class="Comment Code">Honda Accord V6 24</span>
<span class="Comment Code">VW Jetta 32</span>
<span class="Comment Code">**************************************</span>
<span class="Comment Code">Toyotas that have at least 25 mpg</span>
<span class="Comment Code">found 2 result(s):</span>
<span class="Comment Code">------------------</span>
<span class="Comment Code">Toyota Corolla 29</span>
<span class="Comment Code">Toyota Prius 48</span>
<span class="Comment Code">**************************************</span>
<span class="Comment Code">A car that has TDI: VW Golf TDI 41</span>
<span class="Comment Code">*/</span></pre>


</td> </tr> </table> </td> </tr> </table>



</div>



<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->


<div class="NormalText RegFnt ChpCol1" style="padding-top: 10px; ">
<b>Note.</b> If you can't compile this example you should revisit the <a href="#Install">installation</a> section, above.
</div>

<div class="NormalText RegFnt ChpCol1">
I would like to suggest an exercise: <b>try to redo this example</b> with the standard library or with your favorite functor library, just to see what it takes and how easy is it to do it. You'll probably want to add "getter" methods for the data members, to be able to create any functors out of them. But even if you add the "getters", you might have trouble using and combining them. Also, note that most of the code above deals with preparing the vector and displaying the results. There are just a few lines that have anything to do with functors.
</div>

<div class="NormalText RegFnt ChpCol1">
You can find my own attempt at a Boost porting <a href="#BoostCompCode">below</a>. Please don't hesitate to write me if you have a better approach. I'm not really knowledgeable about Boost, so there might be simpler ways to do what I did.
</div>





<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->



<a name="Reference"/>


<div class="ChapterText RegFnt ChpCol2" >
Reference
</div>

<div class="NormalText RegFnt ChpCol2" >
A detailed description of QuickFunctor, fully supported by examples.


<ul class="ListLev1">
    <li> <a href="#FctTypes"> Types of functors </a> </li>
    <li> <a href="#FctCreation"> Creating functors </a> </li>
    <li> <a href="#Operations"> Operations </a> </li>
    <ul class="ListLev1">
        <li> <a href="#OpComp"> <span class="NoBoldInlineCode">comp&lt;n&gt;(f)</span> </a> </li>
        <li> <a href="#OpDerefR"> <span class="NoBoldInlineCode">deref()</span> </a> </li>
        <li> <a href="#OpAddrR"> <span class="NoBoldInlineCode">addr()</span> </a> </li>
        <li> <a href="#OpDerefA"> <span class="NoBoldInlineCode">deref&lt;n&gt;()</span> </a> </li>
        <li> <a href="#OpAddrA"> <span class="NoBoldInlineCode">addr&lt;n&gt;()</span> </a> </li>
        <li> <a href="#OpBind"> <span class="NoBoldInlineCode">bind&lt;n&gt;(x)</span> </a> </li>
        <li> <a href="#OpDel"> <span class="NoBoldInlineCode">del&lt;r, m&gt;()</span> </a> </li>
        <li> <a href="#OpPerm"> <span class="NoBoldInlineCode">perm&lt;n1, n2&gt;()</span>, <span class="NoBoldInlineCode">Perm&lt;n1, n2, n3&gt;()</span>, ... </a> </li>
        <li> <a href="#OpCast"> <span class="NoBoldInlineCode">cast&lt;R&gt;()</span>, <span class="NoBoldInlineCode">cast&lt;R, P1&gt;()</span>, <span class="NoBoldInlineCode">cast&lt;R, P1, P2&gt;()</span>, ... </a> </li>
        <li> <a href="#OpO"> <span class="NoBoldInlineCode">o(f)</span> </a> </li>
    </ul>
    <li> <a href="#ArithmExpr"> Expressions (arithmetic, boolean, string) </a> </li>
    <li> <a href="#AlgUsage"> Usage with algorithms </a> </li>
    <li> <a href="#AsgnExpr"> Assignment expressions </a> </li>
    <li> <a href="#Casting"> Casting </a> </li>
    <li> <a href="#NullFct"> Null functors </a> </li>
    <li> <a href="#UserTypeExpr"> Expressions with a user type </a> </li>
    <li> <a href="#FindSig"> Finding the signature of a functor </a> </li>
    <li> <a href="#ErrorHndl"> Dealing with errors </a> </li>
</ul>


</div>


<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->


<a name="FctTypes"/>

<div class="SubChapterText RegFnt ChpCol1" >
Types of functors
</div>

<div class="NormalText RegFnt ChpCol1" >
Functors are objects of various classes. 
Any functor has exactly one <span class="Hlt">signature</span>, which is a function signature enclosed in brackets <span class="Hlt"><span class="Signature">&lt;R (P1, P2, ... , Pn)&gt;</span></span>. Having that signature means that it has a member function <span class="InlineCode"><span class="Hlt">R operator()(P1, P2, ... , Pn) const</span></span>, so it takes arguments of types <span class="InlineCode">P1</span>, <span class="InlineCode">P2</span>, ... <span class="InlineCode">Pn</span> and returns <span class="InlineCode">R</span>. The maximum number of parameters is determined when generating the file <span class="FileName">Functor.h</span> (see <a href="#OtherNotes">Other notes</a>, below); by default it's 3, and so "n" can take any value between 0 and 3. When n is 0, it means that there are no parameters: the signature <span class="Signature">&lt;R ()&gt;</span> corresponds to a member function <span class="InlineCode">R operator()() const</span>, taking no parameters.
</div>


<div class="NormalText RegFnt ChpCol1" >
A way to classify them would be into "unnamed functors" and "named functors". There are many different functor classes, which, BTW, are template classes, whose template parameters are often other functor classes, so they are usually pretty complex; but the end user doesn't need to know about them, because they should never be used directly. While this complexity doesn't prevent them from being passed to standard algorithms, there are two issues with them: on the one hand it is very cumbersome to have a variable or a parameter with such a type, and on the other hand it doesn't allow genericity. To address these issues, "<span class="Hlt">named functors</span>" have been introduced. They have a simple type, matching their signature. The type <span class="InlineCode"><span class="Hlt">Functor&lt;R (P1, P2, ... , Pn)&gt;</span></span> is a functor with the signature <span class="Signature">&lt;R (P1, P2, ... , Pn)&gt;</span>. The type <span class="InlineCode">Functor&lt;R (P1, P2, ... , Pn)&gt;</span> can easily be used for variables or parameters. The "<span class="Hlt">unnamed</span>" functors are all the others, created by <span class="InlineCode">mkF</span> or by expressions or operations on existing functors. Apart from the fact that the template arguments of the named functors consist of their signature, while the template arguments of the unnamed functors are usually complex and hard to deal with directly, both named and unnamed functors behave the same and support the same operations.
</div>

<div class="NormalText RegFnt ChpCol1" >
The functors from QuickFunctor are immutable. Once they are created, they don't change. The only thing you can do to a functor variable is to assign it a new value. Apart from <span class="InlineCode">operator=()</span>, they only have <span class="InlineCode">const</span> methods. Named functors can be assigned any functor (named or unnamed) that <span class="Hlt">has the same signature</span>.
</div>

<div class="NormalText RegFnt ChpCol1" >
A named functor just containes a wrapper object, which contains a pointer to another (usually unnamed) functor, which has the actual implementation. Initially that wrapper used a class called SharedPtr to handle its pointer. Basically, that shared the same pointer among several named functors. Starting with version 0.8.1.0, this is the default, but you can also use other kinds of "smart pointers". The other one provided is ClonedPtr, which does a "deep clone" of the object pointed to on construction or assignment. You can also write your own. It has to support a simple interface, described at the beggining of the file <span class="FileName">SmartPointers.h</span>. Another one that would be useful but is not provided is a "synchronized <span class="InlineCode">SharedPtr</span>". <span class="InlineCode">SharedPtr</span>'s functions are "non-synchronized", so if you call them from different threads for objects that share a pointer you may leave an object of the class <span class="InlineCode">RefCntHolder</span> (which is an internal class of <span class="InlineCode">SharedPtr</span>) in an inconsistent state, when those threads are simultaneously manipulating references to the same underlying pointer. A "synchronized <span class="InlineCode">SharedPtr</span>" is not provided because it can't be done portably with the standard library only. You can write your own, though, and, upon request, I'll provide information about how to do this if what I said here is not enough.
</div>

<div class="NormalText RegFnt ChpCol1" >
There is a price to pay for the convenience of named functors: they need more memory, they need heap memory, and invoking them causes a virtual function call. The unnamed functors only use the stack (unless allocated with <span class="InlineCode">new</span>) and have no virtual functions. Usually this is of little importance, but sometimes it can noticeably slow down a call (if it's in the innermost loop): on the one hand the virtual call itself usually takes longer, and on the other hand the compiler will be more limited in the optimizations it can perform.
</div>

<div class="NormalText RegFnt ChpCol1" >
In the examples that follow, named functors will be used a lot. That is done mainly to show what are the signatures of the functors involved, but it could have been avoided and it's generally not a good practice to follow in real-world usage of QuickFunctor.
</div>


<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->

<a name="FctCreation"/>

<div class="SubChapterText RegFnt ChpCol2" >
Creating functors
</div>

<div class="NormalText RegFnt ChpCol2" >
Creating functors is not done by calling a constructor, but by calling <span class="InlineCode"><span class="Hlt">mkF</span></span> and its variants, or by calling functor operations on existing functors, or by using expressions.
</div>

<div class="NormalText RegFnt ChpCol2" >
Firstly, there's <span class="InlineCode">mkF</span>. This will create a functor from (almost) any function, variable, constant or numeric or string literal. (There are some exceptions when dealing with classes that don't have a copy constructor.)
</div>

<div class="NormalText RegFnt ChpCol2" >
Sometimes we'd like to create a functor with a different signature than what <span class="InlineCode">mkF</span> would create; perhaps one that takes as its first parameter a pointer to an object, rather than a reference. Or one that returns a <span class="InlineCode">const string&amp;</span> rather than a <span class="InlineCode">string</span>. Sometimes these can be done by using <a href="#OpComp">composition</a>, <a href="#OpCast">casting</a> or other <a href="#Operations">operations</a>, but it's usually more convenient to use one of the "modifiers" (or "suffixes") of <span class="InlineCode">mkF</span>.
</div>

<div class="NormalText RegFnt ChpCol2" >
For functors created from data only (i.e. not from functions) there are <span class="InlineCode"><span class="Hlt">mkFC</span></span>, <span class="InlineCode"><span class="Hlt">mkFR</span></span> and <span class="InlineCode"><span class="Hlt">mkFCR</span></span>. While <span class="InlineCode">mkF</span> creates a functor that returns some value type <span class="InlineCode">V</span>, these variants return <span class="InlineCode">const V</span>, <span class="InlineCode">V&amp;</span> and <span class="InlineCode">const V&amp;</span>, respectively.
</div>

<div class="NormalText RegFnt ChpCol2" >
For functors created by <span class="InlineCode">mkF</span> from members (data or functions) of a class <span class="InlineCode">C</span>, the first parameter of the functor is generally <span class="InlineCode"><span class="Hlt">&amp;C</span></span>, except for <span class="InlineCode">const</span> member functions, for which it is <span class="InlineCode"><span class="Hlt">const C&amp;</span></span>. If that parameter should rather be a pointer (<span class="InlineCode">C*</span> or <span class="InlineCode">const C*</span>), the easiest way to do it is to add an "A" suffix to <span class="InlineCode">mkFXX</span>: <span class="InlineCode"><span class="Hlt">mkFA</span></span>, <span class="InlineCode"><span class="Hlt">mkFCA</span></span>, <span class="InlineCode"><span class="Hlt">mkFRA</span></span> and <span class="InlineCode"><span class="Hlt">mkFCRA</span></span>. These will probably be most useful in code that deals with containers of (smart) pointers to classes. (Note that these are "convenience" functions; the same result could be obtained by using operations or composition on the "reference" functions: <span class="InlineCode">mkFA(f)</span> &lt;=&gt; <span class="InlineCode">mkF(f).addr&lt;1&gt;()</span> &lt;=&gt; <span class="InlineCode">mkF(f).comp&lt;1&gt;(mkF(addr&lt;C&gt;))</span> ).
</div>

<div class="NormalText RegFnt ChpCol2" >
When using named functor types, you may specify a "pointer use policy", to describe how the named functors should handle internally pointers to other functors. By default, <span class="InlineCode">SharedPtr</span> is used, which shares an existing pointer when a named functor with the same type (including both signature and "pointer use policy") is used as a parameter to the copy constructor of a new named functor or to the <span class="InlineCode">operator=()</span> of an existing named functor. This is the default, and so <span class="InlineCode">Functor&lt;int (int), SharedPtr&gt;</span> is equivalent to just <span class="InlineCode">Functor&lt;int (int)&gt;</span>. The alternative is <span class="InlineCode">ClonedPtr</span>, which is recommended to be used when passing named functors among threads, to avoid issues that may result from the fact that <span class="InlineCode">SharedPtr</span>'s implementation is not synchronized. <span class="InlineCode">ClonedPtr</span> should also probably be used when writing your own, mutable functors, derived from <span class="InlineCode">FBase</span>.
</div>

<div class="NormalText RegFnt ChpCol2" >
Here's how the copy constructor and <span class="InlineCode">operator=()</span> work for named functors. They can have a parameter that must be a functor with the same signature. If that functor is also a named functor with the same "pointer use policy", that policy will be taken into consideration and used appropriately. Otherwise, the parameter will be considered "generic" and a new wrapper will be created to hold a pointer to a copy of this parameter. Therefore it's advisable to avoid mixing <span class="InlineCode">ClonedPtr</span> and <span class="InlineCode">SharedPtr</span>, because it may lead to unexpected results when calls are made from different threads.
</div>

<div class="NormalText RegFnt ChpCol2" >
There are some predefined helper functions, which may be useful in some cases, by creating functors from them, with <span class="InlineCode">mkF</span>. They can be used in compositions with existing functors or to simply pass them as arguments to standard algorithms (see the examples with <span class="InlineCode">mkF(identity&lt;int&gt;)</span> in <span class="InlineCode">functorTstAlgorithms()</span>, below, which prints a vector of <span class="InlineCode">int</span>). These functions are located in <span class="FileName">&lt;TemplMiscUtils.h&gt;</span>:
<ul class="ListLev1">
    <li> <span class="InlineCode"><span class="Hlt">template &lt;typename T&gt; T identity(T x)</span></span> - returns what it's passed</li>
    <li> <span class="InlineCode"><span class="Hlt">template &lt;typename T&gt; T&amp; deref(T* p)</span></span> - creates a reference from a pointer</li>
    <li> <span class="InlineCode"><span class="Hlt">template &lt;typename T&gt; T derefV(T* p)</span></span> - creates a value from a pointer</li>
    <li> <span class="InlineCode"><span class="Hlt">template &lt;typename T&gt; T* addr(T&amp; x)</span></span> - creates a pointer from a reference</li>
</ul>
There are also the <a href="#NullFct">null functors</a>, which allow creating functors with a given signature but which don't do anything.



<table border="0" cellpadding="5" cellspacing="2"> <tr> <td/> <td> <table border="0.5" bordercolor="#000000" cellpadding="5" cellspacing="0"> <tr> <td border="2" bgcolor="#ffffe0" bordercolor="#000000" style="font-size: 10px">


<pre><span class="StdType Code">double</span><span class="Regular Code"> f01(</span><span class="StdType Code">int</span><span class="Regular Code"> x, </span><span class="StdType Code">char</span><span class="Regular Code">* p, </span><span class="StdType Code">double</span><span class="Regular Code"> y) { </span><span class="Keyword Code">return</span><span class="Regular Code"> x + *p + y; }</span>


<span class="Keyword Code">struct</span><span class="Regular Code"> TstStruct01</span>
<span class="Regular Code">{</span>
<span class="Regular Code">    </span><span class="StdType Code">int</span><span class="Regular Code"> m() { </span><span class="Keyword Code">return</span><span class="Regular Code"> </span><span class="Integer Code">7</span><span class="Regular Code">; }</span>
<span class="Regular Code">    </span><span class="StdType Code">int</span><span class="Regular Code"> cm() </span><span class="StdType Code">const</span><span class="Regular Code"> { </span><span class="Keyword Code">return</span><span class="Regular Code"> </span><span class="Integer Code">3</span><span class="Regular Code">; }</span>

<span class="Regular Code">    </span><span class="StdType Code">const</span><span class="Regular Code"> </span><span class="StdType Code">int</span><span class="Regular Code"> cn;</span>
<span class="Regular Code">    </span><span class="StdType Code">int</span><span class="Regular Code"> n;</span>
<span class="Regular Code">};</span>


<span class="StdType Code">void</span><span class="Regular Code"> functorTstCreation()</span>
<span class="Regular Code">{</span>
<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"======================= functorTstCreation() ===================================</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>
<span class="Regular Code">    </span><span class="Comment Code">// creating a functor from a global function</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">double</span><span class="Regular Code"> (</span><span class="StdType Code">int</span><span class="Regular Code">, </span><span class="StdType Code">char</span><span class="Regular Code">*, </span><span class="StdType Code">double</span><span class="Regular Code">)&gt; fct1 (mkF(f01));</span>

<span class="Regular Code">    </span><span class="Comment Code">// creating a functor from a value</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> ()&gt; fct2 (mkF(</span><span class="Integer Code">5</span><span class="Regular Code">)); </span><span class="Comment Code">// constant 5</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">long</span><span class="Regular Code"> ()&gt; fct2a (mkF(</span><span class="Integer Code">5L</span><span class="Regular Code">));</span>
<span class="Regular Code">    cout &lt;&lt; fct2() &lt;&lt; </span><span class="StringVal Code">" "</span><span class="Regular Code"> &lt;&lt; fct2a() &lt;&lt; endl; </span><span class="Comment Code">// 5 5</span>

<span class="Regular Code">    </span><span class="Comment Code">// creating a functor from a variable, showing that changing the variable changes the value of the functor</span>
<span class="Regular Code">    </span><span class="StdType Code">int</span><span class="Regular Code"> n (</span><span class="Integer Code">9</span><span class="Regular Code">);</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> ()&gt; fct3 (mkF(n));</span>
<span class="Regular Code">    cout &lt;&lt; fct3() &lt;&lt; endl; </span><span class="Comment Code">// 9</span>
<span class="Regular Code">    n = </span><span class="Integer Code">4</span><span class="Regular Code">; </span><span class="Comment Code">// changing the variable changes the value of the functor</span>
<span class="Regular Code">    cout &lt;&lt; fct3() &lt;&lt; endl; </span><span class="Comment Code">// 4</span>

<span class="Regular Code">    </span><span class="Comment Code">// creating a functor from a variable, showing all the combinations of const and reference</span>
<span class="Regular Code">    string s (</span><span class="StringVal Code">"abc"</span><span class="Regular Code">);</span>
<span class="Regular Code">    Functor&lt;string ()&gt; fct4 (mkF(s)); </span><span class="Comment Code">// return by value</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">const</span><span class="Regular Code"> string ()&gt; fct4a (mkFC(s)); </span><span class="Comment Code">// return by const value</span>
<span class="Regular Code">    Functor&lt;string&amp; ()&gt; fct4b (mkFR(s)); </span><span class="Comment Code">// return by reference</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">const</span><span class="Regular Code"> string&amp; ()&gt; fct4c (mkFCR(s)); </span><span class="Comment Code">// return by const reference</span>


<span class="Regular Code">    </span><span class="Comment Code">//----------------------------------------------------------------------------------</span>

<span class="Regular Code">    </span><span class="Comment Code">// creating a functor from a method, taking a reference as the first param</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> (TstStruct01&amp;)&gt; fct5 (mkF(&amp;TstStruct01::m)); </span><span class="Comment Code">// non-const method</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> (</span><span class="StdType Code">const</span><span class="Regular Code"> TstStruct01&amp;)&gt; fct5a (mkF(&amp;TstStruct01::cm)); </span><span class="Comment Code">// const method</span>

<span class="Regular Code">    </span><span class="Comment Code">// creating a functor from a non-const data member</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> (<span class="Hlt">TstStruct01&amp;</span>)&gt; fct6 (<span class="Hlt">mkF</span>(&amp;TstStruct01::n)); </span><span class="Comment Code">// non-const data member, return by value</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">const</span><span class="Regular Code"> </span><span class="StdType Code">int</span><span class="Regular Code"> (</span><span class="StdType Code">const</span><span class="Regular Code"> TstStruct01&amp;)&gt; fct6a (mkFC(&amp;TstStruct01::n)); </span><span class="Comment Code">// non-const data member, return by const value</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code">&amp; (TstStruct01&amp;)&gt; fct6b (mkFR(&amp;TstStruct01::n)); </span><span class="Comment Code">// non-const data member, return by reference</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">const</span><span class="Regular Code"> </span><span class="StdType Code">int</span><span class="Regular Code">&amp; (</span><span class="StdType Code">const</span><span class="Regular Code"> TstStruct01&amp;)&gt; fct6c (mkFCR(&amp;TstStruct01::n)); </span><span class="Comment Code">// non-const data member, return by const reference</span>

<span class="Regular Code">    </span><span class="Comment Code">// creating a functor from a const data member; like for the non-const, but the results are always const</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">const</span><span class="Regular Code"> </span><span class="StdType Code">int</span><span class="Regular Code"> (TstStruct01&amp;)&gt; fct7 (mkF(&amp;TstStruct01::cn)); </span><span class="Comment Code">// non-const data member, return by value</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">const</span><span class="Regular Code"> </span><span class="StdType Code">int</span><span class="Regular Code"> (</span><span class="StdType Code">const</span><span class="Regular Code"> TstStruct01&amp;)&gt; fct7a (mkFC(&amp;TstStruct01::cn)); </span><span class="Comment Code">// non-const data member, return by const value</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">const</span><span class="Regular Code"> </span><span class="StdType Code">int</span><span class="Regular Code">&amp; (TstStruct01&amp;)&gt; fct7b (mkFR(&amp;TstStruct01::cn)); </span><span class="Comment Code">// non-const data member, return by reference</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">const</span><span class="Regular Code"> </span><span class="StdType Code">int</span><span class="Regular Code">&amp; (</span><span class="StdType Code">const</span><span class="Regular Code"> TstStruct01&amp;)&gt; fct7c (mkFCR(&amp;TstStruct01::cn)); </span><span class="Comment Code">// non-const data member, return by const reference</span>


<span class="Regular Code">    </span><span class="Comment Code">//----------------------------------------------------------------------------------</span>

<span class="Regular Code">    </span><span class="Comment Code">// creating a functor from a method, taking a pointer as the first param</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> (TstStruct01*)&gt; fct8 (mkFA(&amp;TstStruct01::m)); </span><span class="Comment Code">// non-const method</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> (</span><span class="StdType Code">const</span><span class="Regular Code"> TstStruct01*)&gt; fct8a (mkFA(&amp;TstStruct01::cm)); </span><span class="Comment Code">// const method</span>

<span class="Regular Code">    </span><span class="Comment Code">// creating a functor from a non-const data member, taking a pointer</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> (<span class="Hlt">TstStruct01*</span>)&gt; fct9 (<span class="Hlt">mkFA</span>(&amp;TstStruct01::n)); </span><span class="Comment Code">// non-const data member, return by value</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">const</span><span class="Regular Code"> </span><span class="StdType Code">int</span><span class="Regular Code"> (</span><span class="StdType Code">const</span><span class="Regular Code"> TstStruct01*)&gt; fct9a (mkFCA(&amp;TstStruct01::n)); </span><span class="Comment Code">// non-const data member, return by const value</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code">&amp; (TstStruct01*)&gt; fct9b (mkFRA(&amp;TstStruct01::n)); </span><span class="Comment Code">// non-const data member, return by reference</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">const</span><span class="Regular Code"> </span><span class="StdType Code">int</span><span class="Regular Code">&amp; (</span><span class="StdType Code">const</span><span class="Regular Code"> TstStruct01*)&gt; fct9c (mkFCRA(&amp;TstStruct01::n)); </span><span class="Comment Code">// non-const data member, return by const reference</span>

<span class="Regular Code">    </span><span class="Comment Code">// creating a functor from a const data member, taking a pointer</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">const</span><span class="Regular Code"> </span><span class="StdType Code">int</span><span class="Regular Code"> (TstStruct01*)&gt; fct10 (mkFA(&amp;TstStruct01::cn)); </span><span class="Comment Code">// non-const data member, return by value</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">const</span><span class="Regular Code"> </span><span class="StdType Code">int</span><span class="Regular Code"> (</span><span class="StdType Code">const</span><span class="Regular Code"> TstStruct01*)&gt; fct10a (mkFCA(&amp;TstStruct01::cn)); </span><span class="Comment Code">// non-const data member, return by const value</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">const</span><span class="Regular Code"> </span><span class="StdType Code">int</span><span class="Regular Code">&amp; (TstStruct01*)&gt; fct10b (mkFRA(&amp;TstStruct01::cn)); </span><span class="Comment Code">// non-const data member, return by reference</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">const</span><span class="Regular Code"> </span><span class="StdType Code">int</span><span class="Regular Code">&amp; (</span><span class="StdType Code">const</span><span class="Regular Code"> TstStruct01*)&gt; fct10c (mkFCRA(&amp;TstStruct01::cn)); </span><span class="Comment Code">// non-const data member, return by const reference</span>


<span class="Regular Code">    </span><span class="Comment Code">//----------------------------------------------------------------------------------</span>

<span class="Regular Code">    </span><span class="Comment Code">// creating a functor from helper functions</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">const</span><span class="Regular Code"> </span><span class="StdType Code">int</span><span class="Regular Code"> (</span><span class="StdType Code">int</span><span class="Regular Code">)&gt; fct11 (mkF(identity&lt;</span><span class="StdType Code">const</span><span class="Regular Code"> </span><span class="StdType Code">int</span><span class="Regular Code">&gt;)); </span><span class="Comment Code">// !!! not "Functor&lt;const int, const int&gt;":</span>
<span class="Regular Code">                                                </span><span class="Comment Code">// remember that "void f(const int);" is equivalent to "void f(int);"</span>
<span class="Regular Code">    cout &lt;&lt; fct11(</span><span class="Integer Code">15</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 15</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code">&amp; (</span><span class="StdType Code">int</span><span class="Regular Code">*)&gt; fct12 (mkF(deref&lt;</span><span class="StdType Code">int</span><span class="Regular Code">&gt;));</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> (</span><span class="StdType Code">int</span><span class="Regular Code">*)&gt; fct13 (mkF(derefV&lt;</span><span class="StdType Code">int</span><span class="Regular Code">&gt;));</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code">* (</span><span class="StdType Code">int</span><span class="Regular Code">&amp;)&gt; fct14 (mkF(addr&lt;</span><span class="StdType Code">int</span><span class="Regular Code">&gt;));</span>

<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">void</span><span class="Regular Code"> ()&gt; fct15 (mkF(nullFunctor0&lt;</span><span class="StdType Code">void</span><span class="Regular Code">&gt;));</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> (</span><span class="StdType Code">int</span><span class="Regular Code">)&gt; fct16 (mkF(nullFunctor1&lt;</span><span class="StdType Code">int</span><span class="Regular Code">, </span><span class="StdType Code">int</span><span class="Regular Code">&gt;));</span>

<span class="Regular Code">    </span><span class="Comment Code">//----------------------------------------------------------------------------------</span>

<span class="Regular Code">    </span><span class="Comment Code">// creating named functors with specified sharing policy</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">const</span><span class="Regular Code"> </span><span class="StdType Code">int</span><span class="Regular Code"> (</span><span class="StdType Code">int</span><span class="Regular Code">), <span class="Hlt">SharedPtr</span>&gt; fct17 (mkF(identity&lt;</span><span class="StdType Code">const</span><span class="Regular Code"> </span><span class="StdType Code">int</span><span class="Regular Code">&gt;)); </span><span class="Comment Code">// SharedPtr is the default anyway</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> (TstStruct01*), <span class="Hlt">ClonedPtr</span>&gt; fct18 (mkFA(&amp;TstStruct01::m));</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">const</span><span class="Regular Code"> string (), ClonedPtr&gt; fct19 (mkFC(s)); </span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">long</span><span class="Regular Code"> (), ClonedPtr&gt; fct20 (mkF(</span><span class="Integer Code">5L</span><span class="Regular Code">));</span>
<span class="Regular Code">}</span>
</pre>


</td> </tr> </table> </td> </tr> </table>



</div>





<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->

<a name="Operations"/>


<div class="SubChapterText RegFnt ChpCol1" >
Operations
</div>

<div class="NormalText RegFnt ChpCol1" >
You can create another functor from an existing one by using "operations". One interesting thing about functor objects is that they are immutable; they don't change after they are created. The only thing you can do to a functor variable is to asssign it a new value; all the methods are <span class="InlineCode">const</span>.
</div>

<div class="NormalText RegFnt ChpCol1" >
So there are many "operations" that look like they modify a functor, but what they are doing is creating and returning a new one.
</div>

<div class="NormalText RegFnt ChpCol1" >
The supported operations are:
<ul class="ListLev1">
    <a name="OpComp"/> <li class="ListSpace"> <span class="InlineCode"><span class="Hlt">comp&lt;n&gt;(f)</span></span> - Composition on position n with functor <span class="InlineCode">f</span>, with n between 1 <span class="Hlt">(so the numbering is 1-based, and not 0-based)</span> and the number of arguments of the original functor. It's computed by the original functor, with the argument on the position n computed as the result of computing f. The parameters of <span class="InlineCode">f</span> replace the parameter of the original functor in the position n. Given a functor <span class="InlineCode">f1</span> with the signature <span class="Signature">&lt;R (P11, P12)&gt;</span> and a functor <span class="InlineCode">f2</span> with signature <span class="Signature">&lt;R2 (P21, P22)&gt;</span>, <span class="InlineCode">f1.comp&lt;1&gt;(f2)</span> will have the signature <span class="Signature">&lt;R (P21, P22, P12)&gt;</span>, and will be computed by <span class="InlineCode">f1(f2(p1, p2), p3)</span>, while <span class="InlineCode">f1.comp&lt;2&gt;(f2)</span> will have the signature <span class="Signature">&lt;R (P11, P21, P22)&gt;</span>, computed by <span class="InlineCode">f1(p1, f2(p2, p3))</span>. The first case requires that <span class="InlineCode">R2</span> be convertible to <span class="InlineCode">P12</span>, while the second case needs <span class="InlineCode">R2</span> to be convertible to <span class="InlineCode">P22</span>. </li>

    <a name="OpDerefR"/> <li class="ListSpace"> <span class="InlineCode"><span class="Hlt">deref()</span></span> - Dereferences the result. If a functor returns a <span class="InlineCode">T*</span>, the one created by calling <span class="InlineCode">deref()</span> on it will return a <span class="InlineCode">T&amp;</span>. </li>

    <a name="OpAddrR"/> <li class="ListSpace"> <span class="InlineCode"><span class="Hlt">addr()</span></span> - Takes the address of the result, which must be a reference. If a functor returns a <span class="InlineCode">T&amp;</span>, the one created by calling <span class="InlineCode">addr()</span> on it will return a <span class="InlineCode">T*</span>. </li>

    <a name="OpDerefA"/> <li class="ListSpace"> <span class="InlineCode"><span class="Hlt">deref&lt;n&gt;()</span></span> - Dereferences the argument in the position n. If a functor's n<sup>th</sup> argument type is <span class="InlineCode">T*</span>, the one created by calling <span class="InlineCode">deref&lt;n&gt;()</span> on it will have a <span class="InlineCode">T&amp;</span> as its n<sup>th</sup> argument. </li>

    <a name="OpAddrA"/> <li class="ListSpace"> <span class="InlineCode"><span class="Hlt">addr&lt;n&gt;()</span></span> - Takes the address of the argument in the position n, which must be a reference. If a functor's n<sup>th</sup> argument type is <span class="InlineCode">T&amp;</span>, the one created by calling <span class="InlineCode">deref&lt;n&gt;()</span> on it will have a <span class="InlineCode">T*</span> as its n<sup>th</sup> argument. </li>

    <a name="OpBind"/> <li class="ListSpace"> <span class="InlineCode"><span class="Hlt">bind&lt;n&gt;(x)</span></span> - Binds the argument on position n to the value x. </li>

    <a name="OpDel"/> <li class="ListSpace"> <span class="InlineCode"><span class="Hlt">del&lt;r, m&gt;()</span></span> - Removes the argument in the position r, using the one in the position m instead of it (r and m are positions in the original functor). If <span class="InlineCode">f1</span> is a functor with the signature <span class="Signature">&lt;int (long, int, short)&gt;</span> and <span class="InlineCode">f2</span> is <span class="InlineCode">f1.del&lt;2, 3&gt;()</span>, the signature of <span class="InlineCode">f2</span> will be <span class="Signature">&lt;int (long, short)&gt;</span> and it will be calculated as this: <span class="InlineCode">f2(p1, p3)</span> &lt;=&gt; <span class="InlineCode">f1(p1, p3, p3)</span>. </li>

    <a name="OpPerm"/> <li class="ListSpace"> <span class="InlineCode"><span class="Hlt">perm&lt;n1, n2&gt;()</span></span>, <span class="InlineCode"><span class="Hlt">perm&lt;n1, n2, n3&gt;()</span></span>, ... Permutes the arguments of the functor. If <span class="InlineCode">f1</span> is a functor with the signature <span class="Signature">&lt;R (P1, P2, P3)&gt;</span>, then <span class="InlineCode">f1.perm&lt;2, 3, 1&gt;()</span> will have the signature <span class="Signature">&lt;R (P2, P3, P1)&gt;</span>. I did this more as an exercise, to see if it's possible (it needs to calculate the inverse of a permutation with metatemplate programming) and then left it because it gives a sense of completion (and I have a feeling that will prove useful someday). </li>

    <a name="OpCast"/> <li class="ListSpace"> <span class="InlineCode"><span class="Hlt">cast&lt;R&gt;()</span></span>, <span class="InlineCode"><span class="Hlt">cast&lt;R, P1&gt;()</span></span>, <span class="InlineCode"><span class="Hlt">cast&lt;R, P1, P2&gt;()</span></span>, ... - Casts the result and the parameters to new types, using <b><span class="InlineCode">static_cast</span></b>. As an extension, it is possible to cast any result to <span class="InlineCode">void</span>. If <span class="InlineCode">static_cast</span> is not enough, there are <a href="#Casting">helper functions for individual casting</a>, which should be able to handle pretty much anything.</li>

    <a name="OpO"/> <li class="ListSpace"> <span class="InlineCode"><span class="Hlt">o(f)</span></span> - Used as a shortcut for <span class="InlineCode">comp&lt;1&gt;(f)</span>. (This used to be <span class="InlineCode">operator*()</span> in the earlier versions. That was pretty neat, but it had to be removed after introducing the expressions.) </li>
</ul>

</div>

<div class="NormalText RegFnt ChpCol1" >
Most operations create functors with the same number of arguments as the original, but these are the exceptions:
<ul class="ListLev1">
    <li> <span class="InlineCode">bind</span> and <span class="InlineCode">del</span> decrease the number of arguments by 1 </li>
    <li> <span class="InlineCode">f1.comp&lt;n&gt;(f2)</span> will have c1+c2-1 arguments, where c1 is the number of arguments of <span class="InlineCode">f1</span> and c2 is the number of arguments of <span class="InlineCode">f2</span> </li>
</ul>



<table border="0" cellpadding="5" cellspacing="2"> <tr> <td/> <td> <table border="0.5" bordercolor="#000000" cellpadding="5" cellspacing="0"> <tr> <td border="2" bgcolor="#ffffe0" bordercolor="#000000" style="font-size: 10px">


<pre><span class="StdType Code">int</span><span class="Regular Code"> f11(</span><span class="StdType Code">int</span><span class="Regular Code"> x, </span><span class="StdType Code">char</span><span class="Regular Code">* p, </span><span class="StdType Code">int</span><span class="Regular Code"> y) { </span><span class="Keyword Code">return</span><span class="Regular Code"> x + *p + y; }</span>
<span class="StdType Code">char</span><span class="Regular Code">* f12(</span><span class="StdType Code">char</span><span class="Regular Code">&amp; c) { </span><span class="Keyword Code">return</span><span class="Regular Code"> &amp;c; }</span>
<span class="StdType Code">int</span><span class="Regular Code"> f13() { </span><span class="Keyword Code">return</span><span class="Regular Code"> </span><span class="Integer Code">9</span><span class="Regular Code">; }</span>

<span class="StdType Code">void</span><span class="Regular Code"> functorTstOperations()</span>
<span class="Regular Code">{</span>
<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"======================= functorTstOperations() ===================================</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>
<span class="Regular Code">    </span><span class="StdType Code">char</span><span class="Regular Code"> c (</span><span class="Integer Code">10</span><span class="Regular Code">);</span>

<span class="Regular Code">    </span><span class="Comment Code">// a simple functor that returns "int" and takes 3 params (int, char*, int), representing the global function f11</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> (</span><span class="StdType Code">int</span><span class="Regular Code">, </span><span class="StdType Code">char</span><span class="Regular Code">*, </span><span class="StdType Code">int</span><span class="Regular Code">)&gt; fct1 (mkF(f11));</span>
<span class="Regular Code">    cout &lt;&lt; fct1(</span><span class="Integer Code">4</span><span class="Regular Code">, &amp;c, </span><span class="Integer Code">7</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 4+10+7=21</span>

<span class="Regular Code">    </span><span class="Comment Code">// fct2 is built by "composition on position 2", which effectively changes the type of the</span>
<span class="Regular Code">    </span><span class="Comment Code">//    second argument from "char*" to "char&amp;"</span>
<span class="Regular Code">    </span><span class="Comment Code">// fct2(x, y, z) &lt;=&gt; fct1(x, f12(y), z) &lt;=&gt; fct1(x, &amp;y, z)</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> (</span><span class="StdType Code">int</span><span class="Regular Code">, </span><span class="StdType Code">char</span><span class="Regular Code">&amp;, </span><span class="StdType Code">int</span><span class="Regular Code">)&gt; fct2 (fct1.comp&lt;</span><span class="Integer Code">2</span><span class="Regular Code">&gt;(mkF(f12)));</span>
<span class="Regular Code">    cout &lt;&lt; fct2(</span><span class="Integer Code">4</span><span class="Regular Code">, c, </span><span class="Integer Code">7</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 4+10+7=21</span>

<span class="Regular Code">    </span><span class="Comment Code">// by "composition on position 3" with mkF(f13), the third argument is effectively eliminated</span>
<span class="Regular Code">    </span><span class="Comment Code">// fct2a(x, y) &lt;=&gt; fct1(x, y, f13())</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> (</span><span class="StdType Code">int</span><span class="Regular Code">, </span><span class="StdType Code">char</span><span class="Regular Code">*)&gt; fct2a (fct1.comp&lt;</span><span class="Integer Code">3</span><span class="Regular Code">&gt;(mkF(f13)));</span>
<span class="Regular Code">    cout &lt;&lt; fct2a(</span><span class="Integer Code">4</span><span class="Regular Code">, &amp;c) &lt;&lt; endl; </span><span class="Comment Code">// 4+10+9=23</span>

<span class="Regular Code">    </span><span class="Comment Code">// fct3 is built by "dereferencing the argument on position 2", so it behaves identically to fct2</span>
<span class="Regular Code">    </span><span class="Comment Code">// fct3(x, y, z) &lt;=&gt; fct1(x, &amp;y, z) &lt;=&gt; fct2(x, y, z)</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> (</span><span class="StdType Code">int</span><span class="Regular Code">, </span><span class="StdType Code">char</span><span class="Regular Code">&amp;, </span><span class="StdType Code">int</span><span class="Regular Code">)&gt; fct3 (fct1.deref&lt;</span><span class="Integer Code">2</span><span class="Regular Code">&gt;());</span>
<span class="Regular Code">    cout &lt;&lt; fct3(</span><span class="Integer Code">4</span><span class="Regular Code">, c, </span><span class="Integer Code">7</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 4+10+7=21</span>

<span class="Regular Code">    </span><span class="Comment Code">// by "dereferencing" the result of the functor created by mkF(f12),</span>
<span class="Regular Code">    </span><span class="Comment Code">//    we really get the identity functor, returning what was passed to it</span>
<span class="Regular Code">    </span><span class="Comment Code">// since fct4(c) returns a "char&amp;", its result can be passed as the second argument to fct3</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">char</span><span class="Regular Code">&amp; (</span><span class="StdType Code">char</span><span class="Regular Code">&amp;)&gt; fct4 (mkF(f12).deref());</span>
<span class="Regular Code">    cout &lt;&lt; fct3(</span><span class="Integer Code">4</span><span class="Regular Code">, fct4(c), </span><span class="Integer Code">7</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 4+10+7=21</span>

<span class="Regular Code">    </span><span class="Comment Code">// by "taking the address of the argument on position 1" of fct4, that parameter becomes a pointer in fct5</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">char</span><span class="Regular Code">&amp; (</span><span class="StdType Code">char</span><span class="Regular Code">*)&gt; fct5 (fct4.addr&lt;</span><span class="Integer Code">1</span><span class="Regular Code">&gt;());</span>

<span class="Regular Code">    </span><span class="Comment Code">// by "taking the address of the result" of fct4, the result becomes a pointer in fct6</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">char</span><span class="Regular Code">* (</span><span class="StdType Code">char</span><span class="Regular Code">&amp;)&gt; fct6 (fct4.addr());</span>

<span class="Regular Code">    </span><span class="Comment Code">// by "binding on position 3", the third argument is eliminated and the result is the same as fct2a</span>
<span class="Regular Code">    </span><span class="Comment Code">// fct7(x, y) &lt;=&gt; fct1(x, y, 9) &lt;=&gt; fct2a(x, y)</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> (</span><span class="StdType Code">int</span><span class="Regular Code">, </span><span class="StdType Code">char</span><span class="Regular Code">*)&gt; fct7 (fct1.bind&lt;</span><span class="Integer Code">3</span><span class="Regular Code">&gt;(</span><span class="Integer Code">9</span><span class="Regular Code">));</span>
<span class="Regular Code">    cout &lt;&lt; fct7(</span><span class="Integer Code">4</span><span class="Regular Code">, &amp;c) &lt;&lt; endl; </span><span class="Comment Code">// 4+10+9=23</span>

<span class="Regular Code">    </span><span class="Comment Code">// by "replacing the argument on position 3 with the one in position 1", the third argument is eliminated</span>
<span class="Regular Code">    </span><span class="Comment Code">// fct8(x, y) &lt;=&gt; fct1(x, y, x)</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> (</span><span class="StdType Code">int</span><span class="Regular Code">, </span><span class="StdType Code">char</span><span class="Regular Code">*)&gt; fct8 (fct1.del&lt;</span><span class="Integer Code">3</span><span class="Regular Code">, </span><span class="Integer Code">1</span><span class="Regular Code">&gt;());</span>
<span class="Regular Code">    cout &lt;&lt; fct8(</span><span class="Integer Code">4</span><span class="Regular Code">, &amp;c) &lt;&lt; endl; </span><span class="Comment Code">// 4+10+4=18</span>

<span class="Regular Code">    </span><span class="Comment Code">// by "applying the permutation &lt;2, 3, 1&gt;", the order of the arguments is changed</span>
<span class="Regular Code">    </span><span class="Comment Code">// fct9(x, y, z) &lt;=&gt; fct1(y, z, x)</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> (</span><span class="StdType Code">char</span><span class="Regular Code">*, </span><span class="StdType Code">int</span><span class="Regular Code">, </span><span class="StdType Code">int</span><span class="Regular Code">)&gt; fct9 (fct1.perm&lt;</span><span class="Integer Code">2</span><span class="Regular Code">, </span><span class="Integer Code">3</span><span class="Regular Code">, </span><span class="Integer Code">1</span><span class="Regular Code">&gt;());</span>
<span class="Regular Code">    cout &lt;&lt; fct9(&amp;c, </span><span class="Integer Code">4</span><span class="Regular Code">, </span><span class="Integer Code">7</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 10+4+7=21</span>

<span class="Regular Code">    </span><span class="Comment Code">// by "applying casting", static_cast is called for all arguments and for the result</span>
<span class="Regular Code">    </span><span class="Comment Code">// fct10 is like fct1, with "int" cast to "char", so it overflows if passed arguments that are too big</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">char</span><span class="Regular Code"> (</span><span class="StdType Code">char</span><span class="Regular Code">, </span><span class="StdType Code">char</span><span class="Regular Code">*, </span><span class="StdType Code">char</span><span class="Regular Code">)&gt; fct10 (fct1.cast&lt;</span><span class="StdType Code">char</span><span class="Regular Code">, </span><span class="StdType Code">char</span><span class="Regular Code">, </span><span class="StdType Code">char</span><span class="Regular Code">*, </span><span class="StdType Code">char</span><span class="Regular Code">&gt;());</span>
<span class="Regular Code">    cout &lt;&lt; (</span><span class="StdType Code">int</span><span class="Regular Code">)fct10(</span><span class="Integer Code">4</span><span class="Regular Code">, &amp;c, </span><span class="Integer Code">7</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 4+10+7=21</span>
<span class="Regular Code">    cout &lt;&lt; fct1(</span><span class="Integer Code">127</span><span class="Regular Code">, &amp;c, </span><span class="Integer Code">127</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 127+10+127=264;</span>
<span class="Regular Code">    cout &lt;&lt; (</span><span class="StdType Code">int</span><span class="Regular Code">)fct10(</span><span class="Integer Code">127</span><span class="Regular Code">, &amp;c, </span><span class="Integer Code">127</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 127+10+127=264; overflow (on most systems), so probably 8</span>

<span class="Regular Code">}</span></pre>


</td> </tr> </table> </td> </tr> </table>



</div>


<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->



<a name="ArithmExpr"/>

<div class="SubChapterText RegFnt ChpCol2" >
Expressions (arithmetic, boolean, string)
</div>

<div class="NormalText RegFnt ChpCol2" >
As long as two functors return compatible types and take compatible arguments, it is possible to build expressions with them, using the following operators: <span class="Hlt">"+(binary)", "-(binary)", "*(binary)", "/", "%", "&lt;", "&gt;", "&gt;=", "&lt;=", "==", "!=", "&amp;&amp;", "||", "&amp;(binary)", "|", "^", "&lt;&lt;", "&gt;&gt;", "~", "!", "-(unary)", "+(unary)"</span>.
</div>

<div class="NormalText RegFnt ChpCol2" >
If both <span class="InlineCode">f1</span> and <span class="InlineCode">f2</span> have the signature <span class="Signature">&lt;int (int)&gt;</span>, then <span class="InlineCode">f1 + f2</span> is a functor, which has the signature <span class="Signature">&lt;int (int)&gt;</span> too and <span class="InlineCode">(f1 + f2)(a)</span> returns <span class="InlineCode">f1(a) + f2(a)</span>, while <span class="InlineCode">f1 &lt;= f2</span> has the signature <span class="Signature">&lt;bool (int)&gt;</span> and <span class="InlineCode">(f1 &lt;= f2)(a)</span> returns <span class="InlineCode">f1(a) &lt;= f2(a)</span>.
</div>

<div class="NormalText RegFnt ChpCol2" >
What happens if the functors involved in the expression are not of identical signatures? In a few words, the "expression functor" will be compilable and usable if it makes sense, and QuickFunctor tries really hard to do the "right thing". Roughly speaking, its result and parameters will be chosen in such a way as to <span class="Hlt">avoid data loss</span> by truncation. Another thing that is done is choosing the <span class="Hlt">most derived class</span> when the parameters on the same position are classes (or references or pointers to classes). For more details you can see the comments in <span class="FileName">CommonType.h</span> and those in <span class="FileName">ApplyOp.h</span>, but that's a difficult read; better look at the examples and do some experimentation.
</div>

<div class="NormalText RegFnt ChpCol2" >
I took the decision to allow expressions between functors with <span class="Hlt">different number of parameters</span>. For example, by adding a functor <span class="InlineCode">f1</span> with the signature <span class="Signature">&lt;int (int)&gt;</span> to a functor <span class="InlineCode">f2</span> with the signature <span class="Signature">&lt;int (int, int, int)&gt;</span>, the result is going to have the signature <span class="Signature">&lt;int (int, int, int)&gt;</span>. The way the addition works is this: assuming that the parameters are called <span class="InlineCode">x</span>, <span class="InlineCode">y</span> and <span class="InlineCode">z</span>, the result of <span class="InlineCode">(f1+f2)(x, y, z)</span> will be <span class="InlineCode">f1(x) + f2(x, y, z)</span>. It's not completely right to allow this. However in some cases this makes a lot of sense, like when adding (or subtracting, comparing, ...) a functor with the signature <span class="Signature">&lt;int (int)&gt;</span> to a literal constant or to a functor with the signature <span class="Signature">&lt;int ()&gt;</span>. So this is allowed, until I'm presented with reasons good enough to forbid it. To determine the type of the parameters of the "expression functor", CommonParamType (from <span class="FileName">CommonType.h</span>) is called as long as both functors have parameters in some position, and the types for the rest of the parameters are just copied from the remaining types of the functor with more parameters.
</div>

<div class="NormalText RegFnt ChpCol2" >
Another rather unusual thing is the ability to <span class="Hlt">"add" functors that return <span class="InlineCode">void</span></span>. Given two functors <span class="InlineCode">f1</span> and <span class="InlineCode">f2</span>, if at least one of them returns void and their arguments are compatible, they can be "added", with the <span class="InlineCode">+</span> operator. All this does is calling first the first functor, with whatever parameters it needs, and then calling the second functor; any results are ignored. The <span class="InlineCode">f1+f2</span> functor will return void. Being able to have additions (<span class="InlineCode">-</span>, <span class="InlineCode">*</span> or other operations are not allowed) with functors that return <span class="InlineCode">void</span> is something experimental, which I feel might lead to something interesting but I don't currently have a very good reason for allowing it. There's assymetry there, because something can be added but not removed.
</div>

<div class="NormalText RegFnt ChpCol2" >
There's a special treatment for the <span class="InlineCode">&lt;&lt;</span> and <span class="InlineCode">&gt;&gt;</span> operators. They are done in such a way that they <span class="Hlt">work for both numbers and streams</span>. See <span class="InlineCode">fct7</span> and <span class="InlineCode">fct7a</span> in <span class="InlineCode">functorTstArithmExpr()</span> for how would they work with streams, where it's possible to incorporate <span class="InlineCode">std::cout</span> in a functor and print something at every call, without <span class="InlineCode">ostream</span> being even in the signature of <span class="InlineCode">fct7a</span>. Note that the functor for cout is created with <span class="InlineCode">mkFR</span>, because we want to create a reference, not a copy.
</div>


<div class="NormalText RegFnt ChpCol2" >

Note that the header <span class="FileName">&lt;FunctorExpressions.h&gt;</span> is needed for expressions, most likely along with <span class="FileName">&lt;NumericCommonTypes.h&gt;</span> and/or <span class="FileName">&lt;StringCommonTypes.h&gt;</span>.

<table border="0" cellpadding="5" cellspacing="2"> <tr> <td/> <td> <table border="0.5" bordercolor="#000000" cellpadding="5" cellspacing="0"> <tr> <td border="2" bgcolor="#ffffe0" bordercolor="#000000" style="font-size: 10px">


<pre><span class="StdType Code">int</span><span class="Regular Code"> f21(</span><span class="StdType Code">int</span><span class="Regular Code"> x) { </span><span class="Keyword Code">return</span><span class="Regular Code"> x + </span><span class="Integer Code">10</span><span class="Regular Code">; }</span>
<span class="StdType Code">int</span><span class="Regular Code"> f22(</span><span class="StdType Code">short</span><span class="Regular Code"> x) { </span><span class="Keyword Code">return</span><span class="Regular Code"> x * </span><span class="Integer Code">3</span><span class="Regular Code">; }</span>
<span class="StdType Code">int</span><span class="Regular Code"> f23(</span><span class="StdType Code">int</span><span class="Regular Code"> x, </span><span class="StdType Code">int</span><span class="Regular Code"> y) { </span><span class="Keyword Code">return</span><span class="Regular Code"> x/y; }</span>
<span class="Regular Code">string f24(</span><span class="StdType Code">const</span><span class="Regular Code"> string&amp; x) { </span><span class="Keyword Code">return</span><span class="Regular Code"> x + </span><span class="StringVal Code">"#"</span><span class="Regular Code"> + x; }</span>
<span class="StdType Code">const</span><span class="Regular Code"> string&amp; f25(</span><span class="StdType Code">const</span><span class="Regular Code"> string&amp; x) { </span><span class="StdType Code">static</span><span class="Regular Code"> string s; s = </span><span class="StringVal Code">"&gt;&gt;"</span><span class="Regular Code"> + x + </span><span class="StringVal Code">"&lt;&lt;"</span><span class="Regular Code">; </span><span class="Keyword Code">return</span><span class="Regular Code"> s; } </span><span class="Comment Code">// not a good idea to have a "static", but it's just an example</span>


<span class="StdType Code">void</span><span class="Regular Code"> functorTstArithmExpr()</span>
<span class="Regular Code">{</span>
<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"======================= functorTstArithmExpr() ===================================</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>

<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> (</span><span class="StdType Code">int</span><span class="Regular Code">)&gt; fct1 (mkF(f21));</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> (</span><span class="StdType Code">short</span><span class="Regular Code">)&gt; fct2 (mkF(f22));</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> (</span><span class="StdType Code">short</span><span class="Regular Code">)&gt; fct3 (<span class="Hlt">fct1 - fct2</span>); </span><span class="Comment Code">// fct3(x) = (x + 10) - (x * 3)</span>
<span class="Regular Code">    cout &lt;&lt; fct3(</span><span class="Integer Code">4</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// (4+10)-(4*3)=2</span>

<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> (</span><span class="StdType Code">short</span><span class="Regular Code">)&gt; fct4 (mkF(f21) - mkF(f22)); </span><span class="Comment Code">// fct4(x) &lt;=&gt; fct(x)</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> (</span><span class="StdType Code">short</span><span class="Regular Code">)&gt; fct5 (<span class="Hlt">mkF(f21) - </span></span><span class="Integer Code"><span class="Hlt">2</span></span><span class="Regular Code"><span class="Hlt">*mkF(f22) + </span></span><span class="Integer Code"><span class="Hlt">15</span></span><span class="Regular Code">); </span><span class="Comment Code">// fct4(x) = (x + 10) - 2*(x * 3) + 15</span>
<span class="Regular Code">    cout &lt;&lt; fct5(</span><span class="Integer Code">4</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// (4+10)-2*(4*3)+15=5</span>

<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> (</span><span class="StdType Code">int</span><span class="Regular Code">, </span><span class="StdType Code">int</span><span class="Regular Code">)&gt; fct6 (mkF(f21) - mkF(f23)); </span><span class="Comment Code">// fct6(x, y) = (x + 10) - (x / y)</span>
<span class="Regular Code">    cout &lt;&lt; fct6(</span><span class="Integer Code">8</span><span class="Regular Code">, </span><span class="Integer Code">2</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// (8+10)-(8/2)=14</span>

<span class="Regular Code">    (<span class="Hlt">mkFR(cout)</span> &lt;&lt; fct6 &lt;&lt; </span><span class="StringVal Code">"</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">)(</span><span class="Integer Code">8</span><span class="Regular Code">, </span><span class="Integer Code">2</span><span class="Regular Code">); </span><span class="Comment Code">// 14, as before, but the action of evaluatingthe whole functor does both the calculation and the printing</span>
<span class="Regular Code">    Functor&lt;ostream&amp; (</span><span class="StdType Code">int</span><span class="Regular Code">, </span><span class="StdType Code">int</span><span class="Regular Code">)&gt; fct7 (mkFR(cout) &lt;&lt; fct6 &lt;&lt; </span><span class="StringVal Code">"</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">); </span><span class="Comment Code">// the corresponding named functor</span>
<span class="Regular Code">    fct7(</span><span class="Integer Code">15</span><span class="Regular Code">, </span><span class="Integer Code">3</span><span class="Regular Code">); </span><span class="Comment Code">// (15+10)-(15/3)=20 ; evaluating this also does the printing</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">void</span><span class="Regular Code"> (</span><span class="StdType Code">int</span><span class="Regular Code">, </span><span class="StdType Code">int</span><span class="Regular Code">)&gt; fct7a (fct7.cast&lt;</span><span class="StdType Code">void</span><span class="Regular Code">, </span><span class="StdType Code">int</span><span class="Regular Code">, </span><span class="StdType Code">int</span><span class="Regular Code">&gt;());</span>
<span class="Regular Code">    fct7a(</span><span class="Integer Code">15</span><span class="Regular Code">, </span><span class="Integer Code">3</span><span class="Regular Code">); </span><span class="Comment Code">// (15+10)-(15/3)=20 ; <span class="Hlt">evaluating this does the printing, like with fct7, but the signature has no reference to a stream</span></span>

<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"---------- strings ---------"</span><span class="Regular Code"> &lt;&lt; endl;</span>
<span class="Regular Code">    Functor&lt;string (</span><span class="StdType Code">const</span><span class="Regular Code"> string&amp;)&gt; fct8 (mkF(f24) + </span><span class="StringVal Code">" added expr ptr"</span><span class="Regular Code">);</span>
<span class="Regular Code">    cout &lt;&lt; fct8(</span><span class="StringVal Code">"WW"</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// "WW#WW added expr ptr"</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">bool</span><span class="Regular Code"> (string)&gt; fct9 (<span class="Hlt">mkF(identity&lt;string&gt;) == </span></span><span class="StringVal Code"><span class="Hlt">"str1"</span><span class="Regular Code"></span>);</span>
<span class="Regular Code">    string a1 (</span><span class="StringVal Code">"str1"</span><span class="Regular Code">);</span>
<span class="Regular Code">    cout &lt;&lt; fct9(a1) &lt;&lt; fct9(</span><span class="StringVal Code">"str1"</span><span class="Regular Code">) &lt;&lt; fct9(</span><span class="StringVal Code">"str2"</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 110, meaning "true, true, false"</span>

<span class="Regular Code">    Functor&lt;string (</span><span class="StdType Code">const</span><span class="Regular Code"> string&amp;)&gt; fct10 (mkF(f24) + </span><span class="StringVal Code">" *** "</span><span class="Regular Code"> + mkF(f25)); </span><span class="Comment Code">// note that the result is "string", even if f25 returns "const string&amp;"</span>
<span class="Regular Code">    cout &lt;&lt; fct10(</span><span class="StringVal Code">"o"</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// "o#o *** &gt;&gt;o&lt;&lt;"</span>
<span class="Regular Code">}</span>


<span class="Comment Code">//----------------------- parameters of various members belong to derived classes ------------------</span>

<span class="Keyword Code">struct</span><span class="Regular Code"> Base01</span>
<span class="Regular Code">{</span>
<span class="Regular Code">    </span><span class="StdType Code">int</span><span class="Regular Code"> m1() { </span><span class="Keyword Code">return</span><span class="Regular Code"> </span><span class="Integer Code">4</span><span class="Regular Code">; }</span>
<span class="Regular Code">};</span>

<span class="Keyword Code">struct</span><span class="Regular Code"> Der01 : </span><span class="Keyword Code">public</span><span class="Regular Code"> Base01</span>
<span class="Regular Code">{</span>
<span class="Regular Code">    Der01(</span><span class="StdType Code">int</span><span class="Regular Code"> x1) : x(x1) {}</span>
<span class="Regular Code">    Der01(</span><span class="StdType Code">int</span><span class="Regular Code">* p) : x(*p + </span><span class="Integer Code">10</span><span class="Regular Code">) {}</span>
<span class="Regular Code">    </span><span class="StdType Code">int</span><span class="Regular Code"> x;</span>
<span class="Regular Code">    </span><span class="StdType Code">int</span><span class="Regular Code"> m2() </span><span class="StdType Code">const</span><span class="Regular Code"> { </span><span class="Keyword Code">return</span><span class="Regular Code"> x; }</span>
<span class="Regular Code">};</span>

<span class="StdType Code">int</span><span class="Regular Code"> f26(Base01* pb) { </span><span class="Keyword Code">return</span><span class="Regular Code"> pb-&gt;m1(); }</span>
<span class="StdType Code">int</span><span class="Regular Code"> f27(</span><span class="StdType Code">const</span><span class="Regular Code"> Der01* pd) { </span><span class="Keyword Code">return</span><span class="Regular Code"> pd-&gt;m2(); }</span>
<span class="StdType Code">int</span><span class="Regular Code"> f28(</span><span class="StdType Code">int</span><span class="Regular Code">* p) { </span><span class="Keyword Code">return</span><span class="Regular Code"> *p; }</span>
<span class="StdType Code">int</span><span class="Regular Code"> f29(</span><span class="StdType Code">const</span><span class="Regular Code"> Der01&amp; d) { </span><span class="Keyword Code">return</span><span class="Regular Code"> d.m2() + </span><span class="Integer Code">3</span><span class="Regular Code">; }</span>

<span class="StdType Code">void</span><span class="Regular Code"> functorTstArithmExprDer()</span>
<span class="Regular Code">{</span>
<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"====================== functorTstArithmExprDer() =================================</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>

<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> (<span class="Hlt">Der01*</span>)&gt; fct01 (mkF(f26) + mkF(f27) + mkFA(&amp;Base01::m1)); </span><span class="Comment Code">// 4 + x-&gt;x + 4</span>
<span class="Regular Code">    Der01 d (</span><span class="Integer Code">3</span><span class="Regular Code">);</span>
<span class="Regular Code">    cout &lt;&lt; fct01(&amp;d) &lt;&lt; endl; </span><span class="Comment Code">// 11</span>

<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> (</span><span class="StdType Code"><span class="Hlt">int</span></span><span class="Regular Code"><span class="Hlt">*</span>)&gt; fct02 (mkF(f28) * mkF(f29)); </span><span class="Comment Code">// *x * ((*x + 10) + 3)</span>

<span class="Regular Code">    </span><span class="StdType Code">int</span><span class="Regular Code"> x (</span><span class="Integer Code">2</span><span class="Regular Code">);</span>
<span class="Regular Code">    </span><span class="StdType Code">int</span><span class="Regular Code">* p;</span>
<span class="Regular Code">    CommonParamType&lt;</span><span class="StdType Code">int</span><span class="Regular Code">*, </span><span class="StdType Code">const</span><span class="Regular Code"> Der01&amp;&gt;::Type q (&amp;x); </span><span class="Comment Code">// q is a "int*"</span>
<span class="Regular Code">    p = q; </span><span class="Comment Code">// &amp;x</span>
<span class="Regular Code">    cout &lt;&lt; fct02(p) &lt;&lt; endl; </span><span class="Comment Code">// 30</span>
<span class="Regular Code">}</span>


<span class="Comment Code">//---------------------------- expressions with functors that return void --------------------------</span>

<span class="StdType Code">void</span><span class="Regular Code"> f210() { cout &lt;&lt; </span><span class="StringVal Code">"&lt;inside f210&gt;"</span><span class="Regular Code">; }</span>
<span class="StdType Code">void</span><span class="Regular Code"> f211() { cout &lt;&lt; </span><span class="StringVal Code">"&lt;inside f211&gt;"</span><span class="Regular Code">; }</span>
<span class="StdType Code">int</span><span class="Regular Code"> f212() { cout &lt;&lt; </span><span class="StringVal Code">"&lt;inside f212&gt;"</span><span class="Regular Code">; </span><span class="Keyword Code">return</span><span class="Regular Code"> </span><span class="Integer Code">8</span><span class="Regular Code">; }</span>
<span class="StdType Code">int</span><span class="Regular Code"> f213(</span><span class="StdType Code">int</span><span class="Regular Code"> x) { cout &lt;&lt; </span><span class="StringVal Code">"&lt;inside f213; param: "</span><span class="Regular Code"> &lt;&lt; x &lt;&lt; </span><span class="StringVal Code">"&gt;"</span><span class="Regular Code">; </span><span class="Keyword Code">return</span><span class="Regular Code"> </span><span class="Integer Code">8</span><span class="Regular Code">; }</span>

<span class="StdType Code">void</span><span class="Regular Code"> functorTstVoidExpr()</span>
<span class="Regular Code">{</span>
<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"========================= functorTstVoidExpr() ===================================</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>

<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">void</span><span class="Regular Code"> ()&gt; fct1 (mkF(f210));</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">void</span><span class="Regular Code"> ()&gt; fct2 (mkF(f211));</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> ()&gt;  fct3 (mkF(f212));</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">void</span><span class="Regular Code"> ()&gt; fct4 (fct1 + fct2);</span>
<span class="Regular Code">    fct4(); cout &lt;&lt; endl; </span><span class="Comment Code">// &lt;inside f210&gt;&lt;inside f211&gt;</span>
<span class="Regular Code">    fct4 += fct1;</span>
<span class="Regular Code">    fct4(); cout &lt;&lt; endl; </span><span class="Comment Code">// &lt;inside f210&gt;&lt;inside f211&gt;&lt;inside f210&gt;</span>
<span class="Regular Code">    <span class="Hlt">fct4 = fct1 + fct2 + fct3;</span></span>
<span class="Regular Code">    fct4(); cout &lt;&lt; endl; </span><span class="Comment Code">// <span class="Hlt">&lt;inside f210&gt;&lt;inside f211&gt;&lt;inside f212&gt;</span></span>
<span class="Regular Code">    fct4 += fct3;</span>
<span class="Regular Code">    fct4(); cout &lt;&lt; endl; </span><span class="Comment Code">// &lt;inside f210&gt;&lt;inside f211&gt;&lt;inside f212&gt;&lt;inside f212&gt;</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">void</span><span class="Regular Code"> (</span><span class="StdType Code">int</span><span class="Regular Code">)&gt; fct5 (fct4 + mkF(f213));</span>
<span class="Regular Code">    fct5(</span><span class="Integer Code">20</span><span class="Regular Code">); cout &lt;&lt; endl; </span><span class="Comment Code">// &lt;inside f210&gt;&lt;inside f211&gt;&lt;inside f212&gt;&lt;inside f212&gt;&lt;inside f213; param: 20&gt;</span>
<span class="Regular Code">}</span></pre>


</td> </tr> </table> </td> </tr> </table>



</div>



<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->


<a name="AlgUsage"/>

<div class="SubChapterText RegFnt ChpCol1" >
Usage with algorithms
</div>


<div class="NormalText RegFnt ChpCol1" >
Basically you can use them wherever a standard algorithm (like <span class="InlineCode">for_each</span>, <span class="InlineCode">find_if</span>, <span class="InlineCode">partition</span>, ... ) takes a functor. They even have defined <span class="InlineCode">result_type</span>, <span class="InlineCode">argument_type</span>, <span class="InlineCode">first_argument_type</span> and <span class="InlineCode">second_argument_type</span>. A thing to notice is that if you have containers of (smart) pointers, you'll probably want to use the variants of <span class="InlineCode">mkF</span> <span class="Hlt">with the "A" suffix</span> (see <a href="#FctCreation">Creating functors</a>, above), so the functors it creates take pointers too.

<table border="0" cellpadding="5" cellspacing="2"> <tr> <td/> <td> <table border="0.5" bordercolor="#000000" cellpadding="5" cellspacing="0"> <tr> <td border="2" bgcolor="#ffffe0" bordercolor="#000000" style="font-size: 10px">


<pre><span class="StdType Code">int</span><span class="Regular Code"> f31(</span><span class="StdType Code">int</span><span class="Regular Code"> x) { </span><span class="Keyword Code">return</span><span class="Regular Code"> x - </span><span class="Integer Code">1000</span><span class="Regular Code">; }</span>

<span class="Keyword Code">struct</span><span class="Regular Code"> Pers</span>
<span class="Regular Code">{</span>
<span class="Regular Code">    </span><span class="StdType Code">int</span><span class="Regular Code"> m_id;</span>
<span class="Regular Code">    string m_name;</span>
<span class="Regular Code">    </span><span class="StdType Code">const</span><span class="Regular Code"> string&amp; getNameCst() </span><span class="StdType Code">const</span><span class="Regular Code"> { </span><span class="Keyword Code">return</span><span class="Regular Code"> m_name; }</span>
<span class="Regular Code">    </span><span class="StdType Code">const</span><span class="Regular Code"> string&amp; getName() { </span><span class="Keyword Code">return</span><span class="Regular Code"> m_name; }</span>
<span class="Regular Code">    Pers(</span><span class="StdType Code">int</span><span class="Regular Code"> id, string name) : m_id(id), m_name(name) {}</span>
<span class="Regular Code">};</span>


<span class="StdType Code">void</span><span class="Regular Code"> functorTstAlgorithms()</span>
<span class="Regular Code">{</span>
<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"======================= functorTstAlgorithms() ===================================</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>

<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"------------------------------------------------------------------------------</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>
<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"### print vector&lt;int&gt;</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>
<span class="Regular Code">    vector&lt;</span><span class="StdType Code">int</span><span class="Regular Code">&gt; v1;</span>
<span class="Regular Code">    v1.push_back(</span><span class="Integer Code">1000</span><span class="Regular Code">); v1.push_back(</span><span class="Integer Code">1002</span><span class="Regular Code">); v1.push_back(</span><span class="Integer Code">1005</span><span class="Regular Code">);</span>
<span class="Regular Code">    <span class="Hlt">for_each</span>(v1.begin(), v1.end(), mkFR(cout) &lt;&lt; </span><span class="StringVal Code">" ## "</span><span class="Regular Code"> &lt;&lt; <span class="Hlt">mkF(identity&lt;</span></span><span class="StdType Code"><span class="Hlt">int</span></span><span class="Regular Code"><span class="Hlt">&gt;)</span>); </span><span class="Comment Code">//  ## 1000 ## 1002 ## 1005</span>
<span class="Regular Code">    cout &lt;&lt; endl;</span>

<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"### print bitwise negation of vector&lt;int&gt;</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>
<span class="Regular Code">    for_each(v1.begin(), v1.end(), mkFR(cout) &lt;&lt; </span><span class="StringVal Code">" "</span><span class="Regular Code"> &lt;&lt; ~(mkF(identity&lt;</span><span class="StdType Code">int</span><span class="Regular Code">&gt;))); </span><span class="Comment Code">// bitwise negation:  -1001 -1003 -1006</span>
<span class="Regular Code">    cout &lt;&lt; endl;</span>

<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"### print arithmetic negation of vector&lt;int&gt;</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>
<span class="Regular Code">    for_each(v1.begin(), v1.end(), mkFR(cout) &lt;&lt; </span><span class="StringVal Code">" "</span><span class="Regular Code"> &lt;&lt; -(mkF(identity&lt;</span><span class="StdType Code">int</span><span class="Regular Code">&gt;))); </span><span class="Comment Code">// arithmetic negation:  -1000 -1002 -1005</span>
<span class="Regular Code">    cout &lt;&lt; endl;</span>

<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"### find x such that </span><span class="StringSpecChar Code">\"</span><span class="StringVal Code">f31(x) &gt; 1</span><span class="StringSpecChar Code">\"\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>
<span class="Regular Code">    vector&lt;</span><span class="StdType Code">int</span><span class="Regular Code">&gt;::iterator it0 (<span class="Hlt">find_if</span>(v1.begin(), v1.end(), mkF(f31) &gt; </span><span class="Integer Code">1</span><span class="Regular Code">));</span>
<span class="Regular Code">    cout &lt;&lt; *it0 &lt;&lt; endl; </span><span class="Comment Code">// 1002</span>

<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"### custom print of vector&lt;Pers&gt;</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>
<span class="Regular Code">    vector&lt;Pers&gt; v2;</span>
<span class="Regular Code">    v2.push_back(Pers(</span><span class="Integer Code">10</span><span class="Regular Code">, </span><span class="StringVal Code">"name p10"</span><span class="Regular Code">)); v2.push_back(Pers(</span><span class="Integer Code">11</span><span class="Regular Code">, </span><span class="StringVal Code">"name p11"</span><span class="Regular Code">)); v2.push_back(Pers(</span><span class="Integer Code">100</span><span class="Regular Code">, </span><span class="StringVal Code">"name p100"</span><span class="Regular Code">));</span>
<span class="Regular Code">    for_each(v2.begin(), v2.end(), mkFR(cout) &lt;&lt; </span><span class="StringVal Code">" - "</span><span class="Regular Code"> &lt;&lt; mkF(&amp;Pers::m_id) &lt;&lt; </span><span class="StringVal Code">" ["</span><span class="Regular Code"> &lt;&lt; mkF(&amp;Pers::getName) &lt;&lt; </span><span class="StringVal Code">"]</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">);</span>

<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"### find first pers with id &gt; 10 in vector&lt;Pers&gt;</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>
<span class="Regular Code">    vector&lt;Pers&gt;::iterator it21 (find_if(v2.begin(), v2.end(), mkF(&amp;Pers::m_id) &gt; </span><span class="Integer Code">10</span><span class="Regular Code">));</span>
<span class="Regular Code">    cout &lt;&lt; it21-&gt;m_id &lt;&lt; </span><span class="StringVal Code">" "</span><span class="Regular Code"> &lt;&lt; it21-&gt;m_name &lt;&lt; endl;</span>

<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"### find first Pers whose bitwise negation is smaller than -20 in vector&lt;Pers&gt;</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>
<span class="Regular Code">    vector&lt;Pers&gt;::iterator it22 (find_if(v2.begin(), v2.end(), <span class="Hlt">~mkF(&amp;Pers::m_id) &lt; -</span></span><span class="Integer Code"><span class="Hlt">20</span></span><span class="Regular Code">));</span>
<span class="Regular Code">    cout &lt;&lt; it22-&gt;m_id &lt;&lt; </span><span class="StringVal Code">" "</span><span class="Regular Code"> &lt;&lt; it22-&gt;m_name &lt;&lt; endl;</span>



<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"### custom print of vector&lt;Pers*&gt;</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>
<span class="Regular Code">    vector&lt;Pers*&gt; v3;</span>
<span class="Regular Code">    v3.push_back(</span><span class="Keyword Code">new</span><span class="Regular Code"> Pers(</span><span class="Integer Code">10</span><span class="Regular Code">, </span><span class="StringVal Code">"name p10"</span><span class="Regular Code">)); v3.push_back(</span><span class="Keyword Code">new</span><span class="Regular Code"> Pers(</span><span class="Integer Code">11</span><span class="Regular Code">, </span><span class="StringVal Code">"name p11"</span><span class="Regular Code">)); v3.push_back(</span><span class="Keyword Code">new</span><span class="Regular Code"> Pers(</span><span class="Integer Code">100</span><span class="Regular Code">, </span><span class="StringVal Code">"name p100"</span><span class="Regular Code">));</span>
<span class="Regular Code">    for_each(v3.begin(), v3.end(), mkFR(cout) &lt;&lt; </span><span class="StringVal Code">" - "</span><span class="Regular Code"> &lt;&lt; mkFA(&amp;Pers::m_id) &lt;&lt; </span><span class="StringVal Code">" ["</span><span class="Regular Code"> &lt;&lt; mkFA(&amp;Pers::getName) &lt;&lt; </span><span class="StringVal Code">"]</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">);</span>
<span class="Regular Code">    </span><span class="Comment Code">// v3's elements will never be deallocated, but it's just a demo</span>

<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"### find first pers with id &gt; 10 in vector&lt;Pers*&gt;</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>
<span class="Regular Code">    vector&lt;Pers*&gt;::iterator it31 (find_if(v3.begin(), v3.end(), mkFA(&amp;Pers::m_id) &gt; </span><span class="Integer Code">10</span><span class="Regular Code">));</span>
<span class="Regular Code">    cout &lt;&lt; (*it31)-&gt;m_id &lt;&lt; </span><span class="StringVal Code">" "</span><span class="Regular Code"> &lt;&lt; (*it31)-&gt;m_name &lt;&lt; endl;</span>

<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"### find first Pers whose bitwise negation is smaller than -20 in vector&lt;Pers*&gt;</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>
<span class="Regular Code">    vector&lt;Pers*&gt;::iterator it32 (find_if(v3.begin(), v3.end(), <span class="Hlt">~mkFA(&amp;Pers::m_id) &lt; -</span></span><span class="Integer Code"><span class="Hlt">20</span></span><span class="Regular Code">));</span>
<span class="Regular Code">    cout &lt;&lt; (*it32)-&gt;m_id &lt;&lt; </span><span class="StringVal Code">" "</span><span class="Regular Code"> &lt;&lt; (*it32)-&gt;m_name &lt;&lt; endl;</span>
<span class="Regular Code">}</span></pre>


</td> </tr> </table> </td> </tr> </table>



</div>




<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->

<a name="AsgnExpr"/>

<div class="SubChapterText RegFnt ChpCol2" >
Assignment expressions
</div>


<div class="NormalText RegFnt ChpCol2" >

It is possible to use the various assignment operators: <span class="Hlt">"+=", "-=", "*=", "/=", "%=", "&amp;=", "|=", "^=", "&lt;&lt;=", "&gt;&gt;="</span>. If there is a functor <span class="InlineCode">f1</span> with the signature <span class="Signature">&lt;int (string, double)&gt;</span> and a functor <span class="InlineCode">f2</span> with the signature <span class="Signature">&lt;int (string, double)&gt;</span> (or <span class="Signature">&lt;int (string)&gt;</span>, <span class="Signature">&lt;int ()&gt;</span> or even just an <span class="InlineCode">int</span>), it is legal to have <span class="InlineCode">f1 += f2</span>, or <span class="InlineCode">f1 += 42</span>. This feature shouldn't be abused, especially inside loops, because of the way functor expressions are represented. An expression is always going to <span class="Hlt">take more space</span> than the functors used to make it. The results of those expressions are unnamed functors, and so new wrappers are going to be created for them by the named functors, while the original wrappers (if any) will continue to exist. So after "<span class="InlineCode">f1 += 3; f1 -=3;</span>", <span class="InlineCode">f1</span> will return the same values as before these 2 assignments, but it will take additional space for an addition of 3 and a subtraction of 3. Also, the time taken to evaluate the functor will be longer. But sometimes these assignment expressions can really simplify things.

<table border="0" cellpadding="5" cellspacing="2"> <tr> <td/> <td> <table border="0.5" bordercolor="#000000" cellpadding="5" cellspacing="0"> <tr> <td border="2" bgcolor="#ffffe0" bordercolor="#000000" style="font-size: 10px">


<pre><span class="StdType Code">int</span><span class="Regular Code"> f41(</span><span class="StdType Code">int</span><span class="Regular Code"> x, </span><span class="StdType Code">int</span><span class="Regular Code"> y) { </span><span class="Keyword Code">return</span><span class="Regular Code"> x + y; }</span>
<span class="StdType Code">int</span><span class="Regular Code"> f42(</span><span class="StdType Code">int</span><span class="Regular Code"> x, </span><span class="StdType Code">int</span><span class="Regular Code"> y) { </span><span class="Keyword Code">return</span><span class="Regular Code"> x - y; }</span>
<span class="StdType Code">int</span><span class="Regular Code"> f43(</span><span class="StdType Code">int</span><span class="Regular Code"> x) { </span><span class="Keyword Code">return</span><span class="Regular Code"> </span><span class="Integer Code">2</span><span class="Regular Code">*x; }</span>

<span class="StdType Code">void</span><span class="Regular Code"> functorTstAssgnExpr()</span>
<span class="Regular Code">{</span>
<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"======================= functorTstAssgnExpr() ====================================</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> (</span><span class="StdType Code">int</span><span class="Regular Code">, </span><span class="StdType Code">int</span><span class="Regular Code">)&gt; fct1 (mkF(&amp;f41));</span>
<span class="Regular Code">    cout &lt;&lt; fct1(</span><span class="Integer Code">3</span><span class="Regular Code">, </span><span class="Integer Code">6</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 9</span>
<span class="Regular Code">    fct1 = mkF(&amp;f42) + </span><span class="Integer Code">5</span><span class="Regular Code">; </span><span class="Comment Code">// x - y + 5</span>
<span class="Regular Code">    cout &lt;&lt; fct1(</span><span class="Integer Code">3</span><span class="Regular Code">, </span><span class="Integer Code">6</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 2</span>

<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> (</span><span class="StdType Code">int</span><span class="Regular Code">)&gt; fct2 (mkF(&amp;f43)); </span><span class="Comment Code">// 2 * x</span>
<span class="Regular Code">    cout &lt;&lt; fct2(</span><span class="Integer Code">16</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 32</span>

<span class="Regular Code">    <span class="Hlt">fct1 = fct1 + fct2;</span> </span><span class="Comment Code">// 3*x - y + 5</span>
<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"-------- 01 --------</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>
<span class="Regular Code">    cout &lt;&lt; fct1(</span><span class="Integer Code">0</span><span class="Regular Code">, </span><span class="Integer Code">0</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 5</span>
<span class="Regular Code">    cout &lt;&lt; fct1(</span><span class="Integer Code">1</span><span class="Regular Code">, </span><span class="Integer Code">0</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 8</span>
<span class="Regular Code">    cout &lt;&lt; fct1(</span><span class="Integer Code">0</span><span class="Regular Code">, </span><span class="Integer Code">1</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 4</span>
<span class="Regular Code">    cout &lt;&lt; fct1(</span><span class="Integer Code">1</span><span class="Regular Code">, </span><span class="Integer Code">1</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 7</span>

<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"-------- 02 --------</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>
<span class="Regular Code">    cout &lt;&lt; fct1(</span><span class="Integer Code">3</span><span class="Regular Code">, </span><span class="Integer Code">6</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 8</span>
<span class="Regular Code">    cout &lt;&lt; (fct1 + fct2)(</span><span class="Integer Code">2</span><span class="Regular Code">, </span><span class="Integer Code">9</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 6</span>

<span class="Regular Code">    fct1 = mkF(&amp;f41);</span>
<span class="Regular Code">    fct1 = fct1 &lt;&lt; fct2; </span><span class="Comment Code">// (x + y) &lt;&lt; (2*x) , = (x + y)*pow(2, 2*x)</span>
<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"-------- 03 --------</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>
<span class="Regular Code">    cout &lt;&lt; fct1(</span><span class="Integer Code">1</span><span class="Regular Code">, </span><span class="Integer Code">1</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 8</span>
<span class="Regular Code">    cout &lt;&lt; fct1(</span><span class="Integer Code">1</span><span class="Regular Code">, </span><span class="Integer Code">2</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 12</span>
<span class="Regular Code">    cout &lt;&lt; fct1(</span><span class="Integer Code">1</span><span class="Regular Code">, </span><span class="Integer Code">3</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 16</span>
<span class="Regular Code">    cout &lt;&lt; fct1(</span><span class="Integer Code">2</span><span class="Regular Code">, </span><span class="Integer Code">1</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 48</span>
<span class="Regular Code">    cout &lt;&lt; fct1(</span><span class="Integer Code">2</span><span class="Regular Code">, </span><span class="Integer Code">2</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 64</span>
<span class="Regular Code">    cout &lt;&lt; fct1(</span><span class="Integer Code">2</span><span class="Regular Code">, </span><span class="Integer Code">3</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 80</span>
<span class="Regular Code">    cout &lt;&lt; fct1(</span><span class="Integer Code">3</span><span class="Regular Code">, </span><span class="Integer Code">1</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 256</span>
<span class="Regular Code">    cout &lt;&lt; fct1(</span><span class="Integer Code">3</span><span class="Regular Code">, </span><span class="Integer Code">2</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 320</span>
<span class="Regular Code">    cout &lt;&lt; fct1(</span><span class="Integer Code">3</span><span class="Regular Code">, </span><span class="Integer Code">3</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 384</span>

<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"-------- 04 --------</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>
<span class="Regular Code">    fct1 = fct1 &lt;&lt; </span><span class="Integer Code">1</span><span class="Regular Code">; </span><span class="Comment Code">// ((x + y) &lt;&lt; (2*x)) &lt;&lt; 1 , = (x + y)*pow(2, 1 + 2*x)</span>
<span class="Regular Code">    cout &lt;&lt; fct1(</span><span class="Integer Code">2</span><span class="Regular Code">, </span><span class="Integer Code">3</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 160</span>

<span class="Regular Code">    <span class="Hlt">fct1 &gt;&gt;= </span></span><span class="Integer Code"><span class="Hlt">1</span></span><span class="Regular Code"><span class="Hlt">;</span> </span><span class="Comment Code">// (((x + y) &lt;&lt; (2*x)) &lt;&lt; 1) &gt;&gt; 1, = (x + y) &lt;&lt; (2*x) , = (x + y)*pow(2, 2*x)</span>
<span class="Regular Code">    cout &lt;&lt; fct1(</span><span class="Integer Code">2</span><span class="Regular Code">, </span><span class="Integer Code">3</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 80</span>
<span class="Regular Code">    fct1 -= </span><span class="Integer Code">5</span><span class="Regular Code">; </span><span class="Comment Code">// (x + y)*pow(2, 2*x) - 5</span>
<span class="Regular Code">    cout &lt;&lt; fct1(</span><span class="Integer Code">2</span><span class="Regular Code">, </span><span class="Integer Code">3</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 75</span>

<span class="Regular Code">    <span class="Hlt">fct1 -= fct2;</span> </span><span class="Comment Code">// (x + y)*pow(2, 2*x) - 5 - 2*x</span>
<span class="Regular Code">    cout &lt;&lt; fct1(</span><span class="Integer Code">2</span><span class="Regular Code">, </span><span class="Integer Code">3</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 71</span>
<span class="Regular Code">    </span><span class="Comment Code">//??? ++fct1; - probably not</span>

<span class="Regular Code">}</span></pre>


</td> </tr> </table> </td> </tr> </table>



</div>





<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->


<a name="Casting"/>

<div class="SubChapterText RegFnt ChpCol1" >
Casting
</div>

<div class="NormalText RegFnt ChpCol1" >
If you need to do a casting for the result or for the parameters of a functor, there are 2 options. One option is to use the <a href="#OpCast">cast operation</a> described above, which does a <span class="InlineCode">static_cast</span> on all the types involved. If that's not good enough, you can use <span class="InlineCode">mkF</span> on the helper functions <span class="Hlt"><span class="InlineCode">staticCast</span></span>, <span class="Hlt"><span class="InlineCode">dynamicCast</span></span>, <span class="Hlt"><span class="InlineCode">constCast</span></span>, or <span class="Hlt"><span class="InlineCode">reinterpretCast</span></span>, and combine that with the initial functor through composition. To <span class="Hlt">change the type of the result</span> compose a cast function with the original functor (like in <span class="InlineCode">fct1</span>); to <span class="Hlt">change the type of a parameter</span> compose the functor with the cast function (like <span class="InlineCode">fct2a</span>, <span class="InlineCode">fct3a</span> or <span class="InlineCode">fct4a</span>).
</div>

<div class="NormalText RegFnt ChpCol1" >
These functions are located in <span class="FileName">TemplMiscUtils.h</span> (which is included by, <span class="FileName">FullFunctor.h</span>, so if you already have that you also have the cast functions).
</div>

<div class="NormalText RegFnt ChpCol1" >
If there's a need, the result of a functor can be cast to <span class="InlineCode">void</span>, like in <span class="InlineCode">fct4b</span> (where admittedly there wasn't such a great need).

<table border="0" cellpadding="5" cellspacing="2"> <tr> <td/> <td> <table border="0.5" bordercolor="#000000" cellpadding="5" cellspacing="0"> <tr> <td border="2" bgcolor="#ffffe0" bordercolor="#000000" style="font-size: 10px">


<pre><span class="Keyword Code">struct</span><span class="Regular Code"> Base51 { </span><span class="Keyword Code">virtual</span><span class="Regular Code"> ~Base51() {} };</span>
<span class="Keyword Code">struct</span><span class="Regular Code"> Der51 : </span><span class="Keyword Code">public</span><span class="Regular Code"> Base51</span>
<span class="Regular Code">{</span>
<span class="Regular Code">    </span><span class="StdType Code">int</span><span class="Regular Code"> x;</span>
<span class="Regular Code">    Der51(</span><span class="StdType Code">int</span><span class="Regular Code"> x1) : x(x1) {}</span>
<span class="Regular Code">};</span>

<span class="StdType Code">int</span><span class="Regular Code"> f52(</span><span class="StdType Code">int</span><span class="Regular Code">&amp; x) { </span><span class="Keyword Code">return</span><span class="Regular Code"> x + </span><span class="Integer Code">3</span><span class="Regular Code">; }</span>
<span class="StdType Code">int</span><span class="Regular Code"> f53(</span><span class="StdType Code">const</span><span class="Regular Code"> Der51&amp; x) { </span><span class="Keyword Code">return</span><span class="Regular Code"> x.x; }</span>
<span class="StdType Code">int</span><span class="Regular Code"> f54(</span><span class="StdType Code">int</span><span class="Regular Code"> x) { </span><span class="Keyword Code">return</span><span class="Regular Code"> </span><span class="Integer Code">2</span><span class="Regular Code">*x; }</span>


<span class="StdType Code">void</span><span class="Regular Code"> functorTstCast()</span>
<span class="Regular Code">{</span>
<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"========================= functorTstCast() =======================================</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>

<span class="Regular Code">    </span><span class="StdType Code">int</span><span class="Regular Code"> a (</span><span class="Integer Code">5</span><span class="Regular Code">);</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">long</span><span class="Regular Code"> ()&gt; fct1 (mkF(reinterpretCast&lt;</span><span class="StdType Code">long</span><span class="Regular Code">, </span><span class="StdType Code">int</span><span class="Regular Code">*&gt;).o(mkF(&amp;a)));</span>
<span class="Regular Code">    cout &lt;&lt; fct1() &lt;&lt; endl; </span><span class="Comment Code">// address of "a" as an integer</span>

<span class="Regular Code">    </span><span class="StdType Code">const</span><span class="Regular Code"> </span><span class="StdType Code">int</span><span class="Regular Code"> b (</span><span class="Integer Code">9</span><span class="Regular Code">);</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> (</span><span class="StdType Code">int</span><span class="Regular Code">&amp;)&gt; fct2 (mkF(f52));</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> (</span><span class="StdType Code">const</span><span class="Regular Code"> </span><span class="StdType Code">int</span><span class="Regular Code">&amp;)&gt; fct2a (fct2.o(mkF(constCast&lt;</span><span class="StdType Code">int</span><span class="Regular Code">&amp;, </span><span class="StdType Code">const</span><span class="Regular Code"> </span><span class="StdType Code">int</span><span class="Regular Code">&amp;&gt;)));</span>
<span class="Regular Code">    cout &lt;&lt; fct2a(b) &lt;&lt; endl; </span><span class="Comment Code">// 12</span>
<span class="Regular Code">    cout &lt;&lt; mkF(f52).o(mkF(constCast&lt;</span><span class="StdType Code">int</span><span class="Regular Code">&amp;, </span><span class="StdType Code">const</span><span class="Regular Code"> </span><span class="StdType Code">int</span><span class="Regular Code">&amp;&gt;)) (b) &lt;&lt; endl; </span><span class="Comment Code">// 12, same as before but to point out that this can be done "on the fly"</span>

<span class="Regular Code">    </span><span class="StdType Code">const</span><span class="Regular Code"> Base51&amp; c (Der51(</span><span class="Integer Code">7</span><span class="Regular Code">)); </span><span class="Comment Code">// so it's really a derived class object</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> (</span><span class="StdType Code">const</span><span class="Regular Code"> Der51&amp;)&gt; fct3 (mkF(f53));</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> (</span><span class="StdType Code">const</span><span class="Regular Code"> Base51&amp;)&gt; fct3a (<span class="Hlt">fct3.o(mkF(dynamicCast&lt;</span></span><span class="StdType Code"><span class="Hlt">const</span></span><span class="Regular Code"><span class="Hlt"> Der51&amp;, </span></span><span class="StdType Code"><span class="Hlt">const</span></span><span class="Regular Code"><span class="Hlt"> Base51&amp;&gt;))</span>);</span>
<span class="Regular Code">    cout &lt;&lt; fct3a(c) &lt;&lt; endl; </span><span class="Comment Code">// 7</span>

<span class="Regular Code">    </span><span class="StdType Code">double</span><span class="Regular Code"> d (</span><span class="Double Code">3.0</span><span class="Regular Code">);</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> (</span><span class="StdType Code">int</span><span class="Regular Code">)&gt; fct4 (mkF(f54));</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code"> (</span><span class="StdType Code">double</span><span class="Regular Code">)&gt; fct4a (fct4.o(mkF(staticCast&lt;</span><span class="StdType Code">int</span><span class="Regular Code">, </span><span class="StdType Code">double</span><span class="Regular Code">&gt;)));</span>
<span class="Regular Code">    cout &lt;&lt; fct4a(d) &lt;&lt; endl; </span><span class="Comment Code">// 6</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">void</span><span class="Regular Code"> (</span><span class="StdType Code">double</span><span class="Regular Code">)&gt; fct4b (fct4a.cast&lt;</span><span class="StdType Code">void</span><span class="Regular Code">, </span><span class="StdType Code">double</span><span class="Regular Code">&gt;()); </span><span class="Comment Code">// it is possible to cast the result from some type to "void"</span>
<span class="Regular Code">    fct4b(</span><span class="Double Code">1.2</span><span class="Regular Code">);</span>
<span class="Regular Code">}</span></pre>


</td> </tr> </table> </td> </tr> </table>



</div>





<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->


<a name="NullFct"/>

<div class="SubChapterText RegFnt ChpCol2" >
Null functors
</div>



<div class="NormalText RegFnt ChpCol2" >
If you have to work with an interface where you need to pass some kind of functor but in your particular case there is nothing useful that that functor could possibly do, you can create functors that "do nothing", by applying <span class="InlineCode">mkF</span> to one of the null functor helpers: <span class="InlineCode">nullFunctor0&lt;R&gt;</span> for functors without parameters, <span class="InlineCode">nullFunctor1&lt;R, P1&gt;</span> for functors with 1 parameter, ... They return whatever the default constructor for the result returns (that is considered 0 for numeric and pointer types, which lack constructors) and completely ignore the arguments. They also work if the result is <span class="InlineCode">void</span>. More formally, they are:
</div>

<div class="NormalText RegFnt ChpCol2" >
<span class="Hlt"><span class="InlineCode">template &lt;typename T&gt; T nullFunctor0()</span></span>, <span class="Hlt"><span class="InlineCode">template &lt;typename T, typename P1&gt; T nullFunctor1(P1)</span></span>, ...

<table border="0" cellpadding="5" cellspacing="2"> <tr> <td/> <td> <table border="0.5" bordercolor="#000000" cellpadding="5" cellspacing="0"> <tr> <td border="2" bgcolor="#ffffe0" bordercolor="#000000" style="font-size: 10px">


<pre><span class="StdType Code">void</span><span class="Regular Code"> functorTstNullFunctors()</span>
<span class="Regular Code">{</span>
<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"====================== functorTstNullFunctors() ==================================</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>

<span class="Regular Code">    </span><span class="Comment Code">// nothing</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">long</span><span class="Regular Code"> ()&gt; fct1 (mkF(nullFunctor0&lt;</span><span class="StdType Code">long</span><span class="Regular Code">&gt;));</span>
<span class="Regular Code">    cout &lt;&lt; fct1() &lt;&lt; endl; </span><span class="Comment Code">// 0</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">void</span><span class="Regular Code"> ()&gt; fct2 (mkF(nullFunctor0&lt;</span><span class="StdType Code">void</span><span class="Regular Code">&gt;));</span>
<span class="Regular Code">    fct2(); </span><span class="Comment Code">// no output</span>
<span class="Regular Code">    Functor&lt;</span><span class="StdType Code">int</span><span class="Regular Code">* (</span><span class="StdType Code">char</span><span class="Regular Code">)&gt; fct3 (mkF(nullFunctor1&lt;</span><span class="StdType Code">int</span><span class="Regular Code">*, </span><span class="StdType Code">char</span><span class="Regular Code">&gt;));</span>
<span class="Regular Code">    cout &lt;&lt; fct3(</span><span class="StringSpecChar Code">'q'</span><span class="Regular Code">) &lt;&lt; endl; </span><span class="Comment Code">// 0, the param doesn't matter</span>
<span class="Regular Code">}</span></pre>


</td> </tr> </table> </td> </tr> </table>



</div>


<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->


<a name="UserTypeExpr"/>

<div class="SubChapterText RegFnt ChpCol1" >
Expressions with a user type
</div>


<div class="NormalText RegFnt ChpCol1" >
If you want to introduce new classes that are supposed to participate in functor expressions with existing types, you should probably read the comments in <span class="FileName">CommonType.h</span> and those in <span class="FileName">ApplyOp.h</span>. Integration of types like <span class="InlineCode">Fraction</span> or <span class="InlineCode">BigNumber</span> with the existing numerical types isn't that difficult, but it may be hard to understand how to do it. Shortly, you must choose a (probably) new series for your type, call one of the <span class="InlineCode">DEFINE_TYPE_INFOXXX</span> macros and call the <span class="InlineCode">DEFINE_SERIES_ENTRY</span> macro. However, if your new type has operators but <span class="Hlt">doesn't interact with other types, these macros are not needed</span>, as seen below. Expressions of functors using these types can easily be created and used. The functor <span class="InlineCode">fct1</span> is created as an addition of two functors with the signature <span class="Signature">&lt;IntWrapper6  (IntWrapper6)&gt;</span>. However an attempt to create an <span class="InlineCode">fct2</span> as a subtraction of such objects would fail, because <span class="InlineCode">IntWrapper6</span> doesn't define an <span class="InlineCode">operator-()</span>.

<table border="0" cellpadding="5" cellspacing="2"> <tr> <td/> <td> <table border="0.5" bordercolor="#000000" cellpadding="5" cellspacing="0"> <tr> <td border="2" bgcolor="#ffffe0" bordercolor="#000000" style="font-size: 10px">


<pre><span class="Keyword Code">struct</span><span class="Regular Code"> IntWrapper6</span>
<span class="Regular Code">{</span>
<span class="Regular Code">    </span><span class="StdType Code">int</span><span class="Regular Code"> val;</span>
<span class="Regular Code">    IntWrapper6(</span><span class="StdType Code">int</span><span class="Regular Code"> x) : val(x) {}</span>
<span class="Regular Code">    IntWrapper6 </span><span class="Keyword Code">operator</span><span class="Regular Code">+(</span><span class="StdType Code">const</span><span class="Regular Code"> IntWrapper6&amp; o) { </span><span class="Keyword Code">return</span><span class="Regular Code"> IntWrapper6(val + o.val); }</span>
<span class="Regular Code">};</span>

<span class="Regular Code">IntWrapper6 f61(IntWrapper6 x) { </span><span class="Keyword Code">return</span><span class="Regular Code"> IntWrapper6(x.val); }</span>
<span class="Regular Code">IntWrapper6 f62(IntWrapper6 x) { </span><span class="Keyword Code">return</span><span class="Regular Code"> IntWrapper6(x.val*</span><span class="Integer Code">2</span><span class="Regular Code">); }</span>

<span class="StdType Code">void</span><span class="Regular Code"> functorTstStandaloneExpr()</span>
<span class="Regular Code">{</span>
<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"==================== functorTstStandaloneExpr() ==================================</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>
<span class="Regular Code">    Functor&lt;IntWrapper6 (IntWrapper6)&gt; fct1 (<span class="Hlt">mkF(f61) + mkF(f62)</span>);</span>
<span class="Regular Code">    </span><span class="Comment Code">//Functor&lt;IntWrapper6 (IntWrapper6)&gt; fct2 (mkF(f61) - mkF(f62)); // <span class="Hlt">error, no operator-() defined</span></span>
<span class="Regular Code">    IntWrapper6 a (</span><span class="Integer Code">3</span><span class="Regular Code">);</span>
<span class="Regular Code">    cout &lt;&lt; fct1(a).val &lt;&lt; endl; </span><span class="Comment Code">// 9</span>
<span class="Regular Code">    cout &lt;&lt; fct1(</span><span class="Integer Code">7</span><span class="Regular Code">).val &lt;&lt; endl; </span><span class="Comment Code">// 21</span>
<span class="Regular Code">}</span></pre>


</td> </tr> </table> </td> </tr> </table>



</div>




<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->


<a name="FindSig"/>


<div class="SubChapterText RegFnt ChpCol2" >
Finding the signature of a functor
</div>

<div class="NormalText RegFnt ChpCol2" >
Most of the times when your code using functors doesn't compile, it's because some functors have a different signature than the one you'd expect. If <span class="InlineCode">mkF(f1) * mkFA(&amp;C1::f2)</span> doesn't compile, you should look at the signatures of the two functors involved (<span class="InlineCode">mkF(f1)</span> and <span class="InlineCode">mkFA(&amp;C1::f2)</span>) and try to understand where the incompatibilities are. Or, assuming that that one compiles OK but <span class="InlineCode">mkF(f1) * mkFA(&amp;C1::f2) + mkF(w)</span> doesn't, you have to look at the signatures of <span class="InlineCode">mkF(f1) * mkFA(&amp;C1::f2)</span> and of <span class="InlineCode">mkF(w)</span>. While determining the signatures can be done in your mind in the simpler cases, an automated technique would always help.
</div>


<div class="NormalText RegFnt ChpCol2" >
Assuming that you have a functor expression called &lt;your_expression&gt; (which is just a placeholder, so you can substitute it with <span class="InlineCode">mkF(f1) * mkFA(&amp;C1::f2)</span> or anything else), here is a technique based on a compiler error that allows you to find the signature of &lt;your_expression&gt;.
</div>


<div class="NormalText RegFnt ChpCol2" >
Comment out everything that's not working and add the following line:<br/>
<span class="Hlt">Functor&lt;int (int, int, int)&gt; tmpfct = &lt;your_expression&gt;;</span><br/>
Then try to compile. That should give an error message including a <b>VFunctor3Impl</b> (<span class="Hlt">NOT VFunctor3ImplBase</span>), which will allow you to determine the signature of your functor, because the first 4 template arguments of VFunctor3Impl indicate what the actual signature of the functor is (the "4" comes from here: first for result and next 3 for parameters). Note that if the functor has fewer than 3 parameters, VFunctor3Impl will have some arguments of the type <span class="InlineCode">pearl::FunctorNoType</span>; they should be ignored. You can see an example of this in the function <span class="InlineCode">findSig()</span>, in <span class="FileName">other_tests/FunctorExpressionsTst.cpp</span>. To see the actual errors you'll have to uncomment the line with "#define SEE_COMP_SIG_ERR".
</div>

<div class="NormalText RegFnt ChpCol2" >
Well, this technique works with GCC 4.1. If you have a different compiler, it will hopefully give you enough information, including the details of VFunctor3Impl.)
</div>

<div class="NormalText RegFnt ChpCol2" >
Note that this assumed that functors can have at most 3 arguments (as is the default). If you generate the code of <span class="FileName">Functor.h</span> and <span class="FileName">FunctorExpressions.h</span> (see <a href="#OtherNotes">Other notes</a>, below) for other number, you should also adjust the test type to include the maximum number of templates parameters (that would be <span class="InlineCode">Functor&lt;int (int, int, int, int, int)&gt;</span> if the maximum number of arguments is 5, and you should look for a VFunctor5Impl).
</div>




<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->


<a name="ErrorHndl"/>

<div class="SubChapterText RegFnt ChpCol1" >
Dealing with errors
</div>

<!--
<span class="InlineCode RegFnt">
-->

<div class="NormalText RegFnt ChpCol1" >
When something is wrong and the compiler generates an error (or hundreds of errors), I noticed that those errors tend to be quite incomprehensible. Here is some advice on how to deal with them, based on what are you trying to do:
<ul class="ListLev1">
    <li><b>Compiling anything.</b> <span class="Hlt">Remember to include the proper headers</span>: It's easiest to just include <span class="Hlt"><span class="FileName">&lt;FullFunctor.h&gt;</span></span>, which includes all the others. But your compilation times may improve if you only include what is needed. <span class="FileName">&lt;Functor.h&gt;</span> is needed for anything functor-related, and <span class="FileName">&lt;FunctorExpressions.h&gt;</span> is needed for expressions, most likely along with <span class="FileName">&lt;NumericCommonTypes.h&gt;</span> and/or <span class="FileName">&lt;StringCommonTypes.h&gt;</span>. Also, <span class="FileName">&lt;TemplMiscUtils.h&gt;</span> has the <span class="InlineCode">identity</span> and other helper functions (see <a href="#FctCreation">Creating functors</a> and <a href="#Casting">Casting</a>). <p/></li>

    <li><b>Creating functors and expressions of functors.</b> While calling <span class="InlineCode">mkF</span> should work on pretty much anything, trying to build expressions is a different story. The errors most likely to occur are incompatibilities between the arguments or the results of two functors involved in an expression (an <span class="Signature">&lt;int (char*)&gt;</span> and an <span class="Signature">&lt;int (int*)&gt;</span> cannot be added because there is no type that can be converted to both <span class="InlineCode">int*</span> and <span class="InlineCode">char*</span>) or because an operation doesn't make sense for a particular functor (you can't bind the third argument of an <span class="Signature">&lt;int (char*)&gt;</span>, because it only has one argument. <p/>

    So basically if you have a complex expression that doesn't compile, split it into its components, see what signatures they have and implement any correction, most likely by applying an operation or by changing the suffix of a <span class="InlineCode">mkF</span> (if you wanted a <span class="InlineCode">Functor&lt;int (MyClass*)&gt;</span> and used <span class="InlineCode">mkF</span>, you'd get an error; the fix is probably to use <span class="InlineCode">mkFA</span> instead). As a test that an expression has the signature you want, you can assign it to a temporary named functor variable with the appropriate signature and make sure that the code compiles. <p/>

    Also, when calling operations on existing functors (<span class="InlineCode">addr</span>, <span class="InlineCode">comp</span>, <span class="InlineCode">deref</span>, ...), remember that they are <span class="Hlt">functions</span>, so they need parantheses: <span class="InlineCode">mkF(tst).addr&lt;2&gt;<span class="Hlt">()</span></span>, and not just <span class="InlineCode">mkF(tst).addr&lt;2&gt;</span> <p/>

    Another thing to remember is that, when creating functors from function members, a parameter that is a reference (or a pointer) to the class is inserted before the parameters of the function. So the <b>first</b> parameter of the function will be the <b>second</b> parameter of the functor and the <b>second</b> parameter of the function will be the <b>third</b> parameter of the functor. If you use the default number of a maximum of 3 functor parameters, that means that functors can be created from function members with <span class="Hlt">at most 2 parameters</span>. If that's not enough, see (see <a href="#OtherNotes">Other notes</a>, below) for how to generate header files that will allow you to work with more parameters. <p/> 

    In general, trying to create functors that would need more parameters than the maximum allowed can generate some bizarre errors.<p/></li>

    <li><b>Assigning functors to named functors and passing functors as parameters to functions.</b> If you have an assignment / parameter error, find the signature of the functor on the right side and change either that (by operations or variations of <span class="InlineCode">mkF</span> suffixes) or the signature of the named functor. <p/></li>

    <li><b>Calling functors (using their <span class="InlineCode">operator()()</span>).</b> Well, check the signature and change either the functor (by operations or variations of <span class="InlineCode">mkF</span> suffixes) or the actual parameters, so they are compatible. </li>
</ul>
</div>



<div class="NormalText RegFnt ChpCol1" >
Another thing that might be of some help is a function called <span class="InlineCode">seeType(x)</span> in <span class="FileName">&lt;TypeManip.h&gt;</span>, which is supposed to generate a compiler error containing the type of x. With functors, that type will most likely be some obscure class in <span class="FileName">&lt;Functor.h&gt;</span>, which the end user isn't supposed to know about. Still, taking a look and trying to get familiar with what's going on might offer a solution.
</div>




<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->


<a name="AboutCode"/>

<div class="ChapterText RegFnt ChpCol2" >
About the code
</div>

<div class="NormalText RegFnt ChpCol2" >
I expect the code to seem to many people like a potential winner in an "Obfuscated C++" contest. Some things may look quite weird (like the fact that there's only one base class for functors, regardless of the number of parameters, or having a template parameter that is never actually used), others plainly uncompilable, others ignore "good practices" (member functions that can easily be moved out of a class), but the code has changed a lot since when I started developing it and for most things that are there now there is a good reason that they are that way (or that's how it looks to me). Virtually everything was rewritten at least two or three times times, precisely to address some issue or another, so, while the design goals didn't change much, the implementation evolved into something quite different from what was there in the beggining, something that seems to address most of these issues.
</div>

<div class="NormalText RegFnt ChpCol2" >
Currently, few explanations are made about why the code is the way it is and how the trickier parts work. It's a lot of SFINAE (Substitution Failure Is Not An Error) and then some other things, like template metaprogramming (including code to compute the inverse of a permutation). I can try to explain some things that I've done here, if there's such a demand, but the main purpose of a library is to be used, for which it's more important that its interface is well designed and well documented, rather than its implementation being understandable to the casual user. (For one thing, it's usually quite difficult to me to understand what the code in some particular implementation of the STL is doing.)
</div>

<div class="NormalText RegFnt ChpCol2" >
It may seem strange that a class like <span class="InlineCode">Comp</span> or <span class="InlineCode">FunctorExprBase</span> have several <span class="InlineCode">operator()</span>'s, with different number of parameters. However, one will have the signature equal to the functor's signature and will be the only one what will compile (and it will need arguments of the appropriate type). Trying to use one of the others or incompatible parameters will generate a compiler error.
</div>

<div class="NormalText RegFnt ChpCol2" >
The reason <span class="InlineCode">bind&lt;n&gt;()</span> is a member function (as well as all the other operations) is that I find code that uses it much easier to read when dealing with chained calls, because it corresponds to an infix, rather than prefix notation. Compare <br/>
<span style="padding-left: 30px; "><span class="InlineCode">mkF(f1).bind&lt;2&gt;(38).deref&lt;1&gt;().addr().comp&lt;2&gt;(mkF(f2).bind&lt;1&gt;(7))</span></span> to<br/>
<span style="padding-left: 30px; "><span class="InlineCode">comp&lt;2&gt;(addr(deref&lt;1&gt;(bind&lt;2&gt;(mkF(f1), 38))), bind&lt;1&gt;(mkF(f2), 7))</span></span><br/>
While at the first glance they both seem inscrutable, actually in the first case you just go left-to-right to follow what kind of operations are applied, which is arguably easier for most people. In the second case you have to start in the middle and then go back. The initial version of QuickFunctor used global functions, but then I switched to member functions, because from my point of view they are easier to read (but I'm aware that some people have no trouble with a prefix notation).
</div>

<div class="NormalText RegFnt ChpCol2" >
The code provides the "strong exception guarantee" (see Herb Sutter - "Exceptional C++", page 38) to the extent that I remembered to think about it. In several places I noticed that my initial implementation was unnecessarily unsafe and with a few changes I think I made it safe. Nevertheless, I might have missed some parts, but I don't expect this to be a big issue because there are very few dynamic resource allocations and the objects are immutable. If you don't deal with named functors, I guess the "nothrow guarantee" applies. With unnamed functors, all that happens is creating objects on the stack. While you can obviously run out of stack space while doing this, that would trigger some OS-dependent behaviour (like sending a signal) and not throw an exception, anyway. Of course, functors mainly call functions that they are passed at construction, so if those are not safe it doesn't do much good that the functors themselves are.
</div>

<div class="NormalText RegFnt ChpCol2" >
A note about the usage of macros: It is recommended in many places to avoid using macros, for various reasons. Currently there are no "needed" macros in QuickFunctor. In the file <span class="FileName">CommonType.h</span> there are several <span class="InlineCode">DEFINE_TYPE_INFO</span> variants and a <span class="InlineCode">DEFINE_SERIES_ENTRY</span>. They are used only to prevent some mistakes, and the code could have been written entirely without them (but more prone to bugs). The end user only has to deal with them when integrating new types with existing types that are used as functor results or parameters in functor expressions, and that is done only once for every new type, so it's quite minimal. I considered using some macros to shorten operation calls that are made very often (like <span class="InlineCode">ADDR1</span> for <span class="InlineCode">addr&lt;1&gt;()</span>), but for now I decided to refrain from doing it.
</div>


<div class="NormalText RegFnt ChpCol2" >
As far as I can tell, the code conforms to the current C++ standard, but I'm not really an expert, so there's a chance that it compiles and works in my environment even though it shouldn't.
</div>





<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->

<a name="LookingAtCode"/>

<div class="ChapterText RegFnt ChpCol1" >
Looking at the source code
</div>

<div class="NormalText RegFnt ChpCol1" >
First of all, just because it's available, it doesn't mean that you have to look at it. It's probably better to just look at the documentation and examples.
</div>

<div class="NormalText RegFnt ChpCol1" >
The only file meant to be looked at is <span class="FileName">FunctorTst.cpp</span>, although efforts were made for the non-generated header files to be readable, under certain circumstances.
</div>

<div class="NormalText RegFnt ChpCol1" >
I expect that trying to examine the code is going to be annoying for many people, partly for my naming conventions and indentation style, but perhaps more for the length of the lines. The thing is that that's how I like it, because it allows more information to be displayed on the screen (and I can actually handle it all). So I use a 1600x1200 screen resolution, with the IDE maximized and a font that displays 210 characters per line. The editor must support (soft) word wrapping for the comments to be readable. I use KDevelop, which has this feature and the added bonus that the continuation of the line starts in the same column as the beginning of the line, and not in column 1. Something to alleviate this issue might be using proportional fonts, but the comments would still generally be too long. My intention was to pass all the files through a beautifier/formatter before releasing them, to get everything to the 80 chars per line that everybody seems to love. Unfortunately, I couldn't find one. While there are some that claim to handle C++, those that I tried seem to actually be slightly modified C beautifiers, which know very little about templates. That's a big issue, as QuickFunctor is a template library, and templates are everywhere. As for the comments, I found that I change them so often that it's a nightmare to keep them properly formatted if I use line breaks inside paragraphs. There are perhaps editors that realign paragraphs inside comments, but I haven't looked into this. Maybe I'll switch to 80-char lines once things start to stabilize.
</div>

<div class="NormalText RegFnt ChpCol1" >
Another thing to keep in mind is that the files <span class="FileName">Functor.h</span> and <span class="FileName">FunctorExpressions.h</span> are generated (see <a href="#OtherNotes">Other notes</a>, below), by default handling functors with up to 3 parameters.
</div>

<div class="NormalText RegFnt ChpCol1" >
If you still want to look at the source code, there's another thing to know, namely some labels inside comments:
<ul class="ListLev1">
    <li> "+++" is for something that has to be done in the future (i.e. TODO) </li>
    <li> "ddd" is for something that should be revisited in the future, and perhaps implemented </li>
    <li> "???" is similar to ddd but emphasizes a particular idea that should be clarified </li>
    <li> "!!!" is used in those places where a casual glance at the code might suggest that it's wrong and has to be fixed, while in fact the "obvious correction" is wrong; or just simply to point out something that is unusual </li>
</ul>

</div>




<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->

<a name="StdComparison"/>

<!--
<table border="0" cellpadding="5" cellspacing="2"> 
    <tr>
        <td border="2" style="">
            Standard
        </td>
        <td border="2" style="">
            QuickFunctor
        </td>
    </tr>

</table>

-->

<div class="ChapterText RegFnt ChpCol2" >
A comparison to the standard
</div>

<div class="NormalText RegFnt ChpCol2" >
Here I try to make a comparison between QuickFunctor and the Standard Library. It might not be completely accurate, because I don't know the standard implementation very well (because I don't use it).
</div>

<div class="SmalllText RegFnt ChpCol2" style="padding-left: 20px">
<table border="1" cellpadding="5" cellspacing="0" bgcolor="#ffffe0" >
    <tr class="SmalllText">
        <td> <b>Operation</b> </td>
        <td> <b>Standard</b> </td>
        <td> <b>QuickFunctor</b> </td>
    </tr>
    <tr class="SmalllText">
        <td> create functor from member function, taking a reference </td>
        <td class="InlineCode"> mem_fun_ref </td>
        <td class="InlineCode"> mkF </td>
    </tr>
    <tr class="SmalllText">
        <td> create functor from member function, taking a pointer </td>
        <td class="InlineCode"> mem_fun </td>
        <td class="InlineCode"> mkFA </td>
    </tr>
    <tr class="SmalllText">
        <td> create functor from global function with 1 or 2 parameters </td>
        <td class="InlineCode"> ptr_fun </td>
        <td class="InlineCode"> mkF </td>
    </tr>
    <tr class="SmalllText">
        <td> create functor from global function with 3 (or more) parameters </td>
        <td> N/A </td>
        <td class="InlineCode"> mkF </td>
    </tr>
    <tr class="SmalllText">
        <td> create functor from member data, global or local variables or constants </td>
        <td> N/A </td>
        <td class="InlineCode"> mkF, mkFR, mkFC, mkFCR, mkFA, mkFRA, mkFCA, mkFCRA </td>
    </tr>
    <tr class="SmalllText">
        <td> binding first argument </td>
        <td class="InlineCode"> bind1st </td>
        <td class="InlineCode"> bind&lt;1&gt; </td>
    </tr>
    <tr class="SmalllText">
        <td> binding second argument </td>
        <td class="InlineCode"> bind2nd </td>
        <td class="InlineCode"> bind&lt;2&gt; </td>
    </tr>
    <tr class="SmalllText">
        <td> binding third argument </td>
        <td> N/A </td>
        <td class="InlineCode"> bind&lt;3&gt; </td>
    </tr>
    <tr class="SmalllText">
        <td> logical negators for functors taking one or two arguments </td>
        <td class="InlineCode"> not1, not2 </td>
        <td class="InlineCode"> ! </td>
    </tr>
    <tr class="SmalllText">
        <td> logical negators for functors taking 3 (or more) arguments </td>
        <td> N/A </td>
        <td class="InlineCode"> ! </td>
    </tr>
    <tr class="SmalllText">
        <td> other unary operations for functors </td>
        <td> N/A </td>
        <td class="InlineCode"> ~, -, + </td>
    </tr>
    <tr class="SmalllText">
        <td> binary operations for functors </td>
        <td> N/A </td>
        <td class="InlineCode"> +, -, *, /, %, &lt;, &gt;, &gt;=, &lt;=, ==, !=, &amp;&amp;, ||, &amp;, |, ^, &lt;&lt;, &gt;&gt; </td>
    </tr>
    <tr class="SmalllText">
        <td> assignment operations for functors </td>
        <td> N/A </td>
        <td class="InlineCode"> +=, -=, *=, /=, %=, &amp;=, |=, ^=, &lt;&lt;=, &gt;&gt;= </td>
    </tr>
    <tr class="SmalllText">
        <td> other "transform" operations (besides binding and negation) </td>
        <td> N/A </td>
        <td class="InlineCode"> comp, deref, addr, deref&lt;n&gt;, addr&lt;n&gt;, perm, cast </td>
    </tr>
    <tr class="SmalllText">
        <td> helpers </td>
        <td class="InlineCode"> equal_to, not_equal_to, greater, greater_equal, less, less_equal, logical_and, logical_or, multiplies, divides, plus, minus, modulus </td>
        <td class="InlineCode"> identity, deref, derefV, addr, staticCast, dynamicCast, constCast, reinterpretCast, nullFunctor0(), nullFunctor1(P1), ... </td>
    </tr>
    <tr class="SmalllText">
        <td> named functors </td>
        <td> N/A </td>
        <td class="InlineCode"> Functor&lt;R&gt;, Functor&lt;R, P1&gt;, Functor&lt;R, P1, P2&gt;, Functor&lt;R, P1, P2, P3&gt; </td>
    </tr>

</table>


</div>

<div class="NormalText RegFnt ChpCol2" >
I don't believe there's any way to "port" the <a href="#UsageSample">car example</a> to use only the Standard Library. By that I mean that you can write code that does the same thing, but you'll have to create new classes and/or functions. This is unlike <a href="#BoostCompCode">Boost Lambda</a>, where you can just substitute QuickFunctor calls with Boost calls. However, what's missing from the standard is "composition". So if you somehow add "composition" (write your own or get it from somewhere), then I guess you can also port the example to the Standard Library.
</div>


<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->


<a name="BoostComparison"/>

<div class="ChapterText RegFnt ChpCol1" >
A comparison to the Boost Library
</div>

<div class="NormalText RegFnt ChpCol1" >
Well, before I started to work on QuickFunctor I took a look at Boost and my reactions were mixed. While it obviously could do many things, the way to achieve something seemed too complicated. The same stays true now, after I took a closer look (but maybe not close enough). Maybe it's just about getting used to it, but I think I managed to create a smaller and more coherent package from what you find in Boost in the Lambda and Function libraries, (well, there is related functionality in Bind and Mem_fn, but I believe that Lambda supercedes them, at least in the areas that have functionality similar to QuickFunctor). Anyway, the thing is that <b>I don't know Boost well enough to make a "fair and balanced" comparison</b> (even assuming that I can stay objective).
</div>

<div class="NormalText RegFnt ChpCol1" >
Functionally speaking, Boost has some features that are not present in QuickFunctor, like the equivalent of comparison of named pointers or all sorts of classes to perform loops, tests, exception catching and more in a functor that you're building (if_then(condition, then_part), if_then_else(condition, then_part, else_part), if_then_else_return(condition, then_part, else_part), while_loop(condition, body), ...). No doubt, there are quite a few more things that you're going to find in Boost without an equivalent in QuickFunctor. But to me it seems that it's hard to write quickly code that uses them correctly.
</div>

<div class="NormalText RegFnt ChpCol1" >
On the other hand, QuickFunctor comes with a lot of features, like a code generator that allows you to <a href="#OtherNotes">generate header files</a> that handle functors with more than 3 parameters and, well, perhaps that's it. Or maybe not :
</div>

<div class="NormalText RegFnt ChpCol1" >
I feel a bit uneasy that some Boost functions will take whatever you throw at them and try to do "the right thing" (e.g. the fact that you can bind both a pointer and a regular variable to a functor taking a pointer, or that the declaration <span class="InlineCode">function&lt;bool (Car&amp;)&gt; f1 = &amp;Car::mpg;</span> succeeds, despite <span class="InlineCode">mpg()</span>'s returning an <span class="InlineCode">int</span>, not a <span class="InlineCode">bool</span>). But that's a matter of taste, I guess. I tend to favor a more strict type checking, one that forces you to explicitly make a "cast", if one is needed. Related to this, I feel that it's easier in QuickFunctor to control whether parameters are passed by value or by reference.
</div>

<div class="NormalText RegFnt ChpCol1" >
Another issue that I have with the Boost approach is that if the underscore is missing and you just have <span class="InlineCode">1</span>, <span class="InlineCode">2</span> or <span class="InlineCode">3</span> instead of <span class="InlineCode">_1</span>, <span class="InlineCode">_2</span> or <span class="InlineCode">_3</span>, in many cases the code will compile just fine.
</div>

<div class="NormalText RegFnt ChpCol1" >
I don't know how easy it is to determine the signature of a lambda expression. For QuickFunctor there is a <a href="#FindSig">"compiler error" - based</a> method. I guess something along these lines would work with Boost too.
</div>

<div class="NormalText RegFnt ChpCol1" >
I don't know how the pointer handling policy introduced in QuickFunctor 0.8.1.0 compares to Boost. QuickFunctor' named functors internally use some "smart pointers", that can be told to share or clone existing objects during construction and assignments. This is done by providing a second template argument when specifying the type of a named pointer.
</div>

<div class="NormalText RegFnt ChpCol1" >
It seems that most of the things covered by QuickFunctor can be done somehow by Boost Lambda. It's just that <b>to me</b> the way QuickFunctor does things looks more natural and less error prone (I'm talking about the user code, the library implementation is a different story). I can't seem to get used to <span class="InlineCode">_1</span>, <span class="InlineCode">_2</span> and <span class="InlineCode">_3</span> and to the fact that anything you might ever want to do with functors is done using <span class="InlineCode">bind()</span>.
</div>

<div class="NormalText RegFnt ChpCol1" >
Since QuickFunctor needed the SP1 version of MSVC 2005 to work and it wouldn't compile with the original version, it's going to have more portability issues than Boost Lambda.
</div>

<a name="BoostCompCode"/>

<div class="NormalText RegFnt ChpCol1" >
I spent some time porting my <a href="#UsageSample">car example</a> to Boost. It didn't go very smoothly, but I got it working. At first I couldn't figure how to use the Lambda library so I had an implementation based on the Bind library. It had code looking like this:
<table border="0" cellpadding="5" cellspacing="2"> <tr> <td/> <td> <table border="0.5" bordercolor="#000000" cellpadding="5" cellspacing="0"> <tr> <td border="2" bgcolor="#ffffe0" bordercolor="#000000" style="font-size: 10px">

<pre><span class="Regular Code"></span><span class="Comment Code">//findCars(v, mkF(&amp;Car::make) == "Toyota" &amp;&amp; mkF(&amp;Car::mpg) &gt;= 25);</span>
<span class="Regular Code">findCars(v, bind(logical_and&lt;</span><span class="StdType Code">bool</span><span class="Regular Code">&gt;(), </span>
<span class="Regular Code">    bind(equal_to&lt;string&gt;(), bind(&amp;Car::make, _1), </span><span class="StringVal Code">"Toyota"</span><span class="Regular Code">), </span>
<span class="Regular Code">    bind(greater_equal&lt;</span><span class="StdType Code">int</span><span class="Regular Code">&gt;(), bind(&amp;Car::mpg, _1), </span><span class="Integer Code">25</span><span class="Regular Code">)));</span></pre>


</td> </tr> </table> </td> </tr> </table>

</div>


<div class="NormalText RegFnt ChpCol1" >
It didn't strike me as particularly pretty, and I was convinced that something better could be done. After digging some more through the documentation, I came up with a Lambda-based implementation. Here is where it differs from the QuickFunctor version (the QuickFunctor variant is commented out, above each line of Boost-specific code):

<table border="0" cellpadding="5" cellspacing="2"> <tr> <td/> <td> <table border="0.5" bordercolor="#000000" cellpadding="5" cellspacing="0"> <tr> <td border="2" bgcolor="#ffffe0" bordercolor="#000000" style="font-size: 10px">

<pre><span class="Keyword Code">[...]</span>

<span class="Comment Code">//#include &lt;FullFunctor.h&gt;</span>
<span class="Preproc Code">#include &lt;boost/lambda/lambda.hpp&gt;</span>
<span class="Preproc Code">#include &lt;boost/lambda/bind.hpp&gt;</span>
<span class="Preproc Code">#include &lt;boost/function.hpp&gt;</span>

<span class="Keyword Code">[...]</span>
<span class="Comment Code">//using namespace pearl;</span>
<span class="Keyword Code">using</span><span class="Regular Code"> </span><span class="Keyword Code">namespace</span><span class="Regular Code"> boost;</span>
<span class="Keyword Code">using</span><span class="Regular Code"> </span><span class="Keyword Code">namespace</span><span class="Regular Code"> boost::lambda;</span>

<span class="Keyword Code">[...]</span>
<span class="Comment Code">//void findCars(vector&lt;Car&gt;&amp; v, const Functor&lt;bool (Car&amp;)&gt;&amp; test)</span>
<span class="StdType Code">void</span><span class="Regular Code"> findCars(vector&lt;Car&gt;&amp; v, </span><span class="StdType Code">const</span><span class="Regular Code"> function&lt;</span><span class="StdType Code">bool</span><span class="Regular Code"> (Car&amp;)&gt;&amp; test)</span> <span class="Keyword Code">[...]</span>

<span class="StdType Code">bool</span><span class="Regular Code"> hasTdi(</span><span class="StdType Code">const</span><span class="Regular Code"> string&amp; s)</span> <span class="Keyword Code">[...]</span>

<span class="StdType Code">void</span><span class="Regular Code"> sampleUsage()</span>
<span class="Regular Code">{</span>
<span class="Regular Code">    vector&lt;Car&gt; v;</span>
<span class="Keyword Code">    [...]</span>
<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"Cars that have at least 23 mpg</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>
<span class="Regular Code">    </span><span class="Comment Code">//findCars(v, mkF(&amp;Car::mpg) &gt;= 23);</span>
<span class="Regular Code">    findCars(v, bind(&amp;Car::mpg, _1) &gt;= </span><span class="Integer Code">23</span><span class="Regular Code">);</span>

<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"Cars that have the mpg between 23 and 41</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>
<span class="Regular Code">    </span><span class="Comment Code">//findCars(v, mkF(&amp;Car::mpg) &gt;= 23 &amp;&amp; mkF(&amp;Car::mpg) &lt;= 41);</span>
<span class="Regular Code">    findCars(v, bind(&amp;Car::mpg, _1) &gt;= </span><span class="Integer Code">23</span><span class="Regular Code"> &amp;&amp; bind(&amp;Car::mpg, _1) &lt;= </span><span class="Integer Code">41</span><span class="Regular Code">);</span>

<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"Toyotas that have at least 25 mpg</span><span class="StringSpecChar Code">\n</span><span class="StringVal Code">"</span><span class="Regular Code">;</span>
<span class="Regular Code">    </span><span class="Comment Code">//findCars(v, mkF(&amp;Car::make) == "Toyota" &amp;&amp; mkF(&amp;Car::mpg) &gt;= 25);</span>
<span class="Regular Code">    findCars(v, bind(&amp;Car::make, _1) == </span><span class="StringVal Code">"Toyota"</span><span class="Regular Code"> &amp;&amp; bind(&amp;Car::mpg, _1) &gt;= </span><span class="Integer Code">25</span><span class="Regular Code">);</span>

<span class="Regular Code">    vector&lt;Car&gt;::iterator it;</span>
<span class="Regular Code">    </span><span class="Comment Code">//it = find_if(v.begin(), v.end(), mkF(hasTdi).comp&lt;1&gt;(mkF(&amp;Car::model)));</span>
<span class="Regular Code">    </span><span class="Comment Code">////  mkF(hasTdi).o(mkF(&amp;Car::model)) is a shortcut for the test above</span>
<span class="Regular Code">    it = find_if(v.begin(), v.end(), bind(hasTdi, bind(&amp;Car::model, _1)));</span>
<span class="Regular Code">    cout &lt;&lt; </span><span class="StringVal Code">"A car that has TDI: "</span><span class="Regular Code"> &lt;&lt; (*it) &lt;&lt; endl;</span>
<span class="Regular Code">}</span></pre>


</td> </tr> </table> </td> </tr> </table>

Since I'm not very well acquainted with Boost, chances are that a better implementation exists, but this looks good enough to me. Please let me know if you can think of a better one.
</div>

<div class="NormalText RegFnt ChpCol1" >
To me, the QuickFunctor version looks (quite unsurprisingly) slightly better, in the sense that I see it as more expressive and easier to develop with and to understand (I think it's easier to understand what <span class="InlineCode">mkF</span> does than to figure what <span class="InlineCode">bind</span> and <span class="InlineCode">_1</span> will do in some cases). Probably it's the other way around for somebody who uses Boost frequently for this kind of things. 
</div>

<div class="NormalText RegFnt ChpCol1" >
Anyway, the actual question for a fair comparison comes down to the learning curve, the time it takes to get your code to compile and to do what you want, as well as the features that real users actually use. It's probably irrelevant that QuickFunctor has permutations; most users are never going to use them, unless some kind of programming idiom becomes popular that could benefit from such a feature. Well, Boost Lambda also has permutations, as well as many other things, but that is of little importance if nobody uses them.
</div>

<div class="NormalText RegFnt ChpCol1" >
Of course, performance matters too. I didn't do any performance comparison, but I'm pretty sure that QuickFunctor will be fast enough, maybe after some tweaks.
</div>

<div class="NormalText RegFnt ChpCol1" >
Sure, nothing prevents you from using both libraries in your programs, but I probably wouldn't do such a thing in a new program; or maybe, if each has a very important feature that's missing from the other. But there is a lot of overlap.
</div>


<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->


<a name="TR1Comparison"/>

<div class="ChapterText RegFnt ChpCol2" >
A comparison to the TR1 Library
</div>

<div class="NormalText RegFnt ChpCol2" >
First of all, I don't have a good understanding of TR1, so you should double-check this. It seems to me that roughly TR1 copied from Boost the libraries Function, Bind and Mem_fn. Judging by <a href="http://www.dinkumware.com/tr1_compare.aspx">this</a> Dinkumware page, it seems that only they have anything resembling a full TR1 implementation. Anyway, I don't have a complete TR1, so I couldn't actually test what works. I'm inclined to believe that <a href="#BoostCompCode">my first Boost implementation</a> (the one using <span class="InlineCode">logical_and</span>) or something close to it will work (you'll have to include the proper headers). Apparently you can't build expressions with the arithmetic operators. 
</div>

<div class="NormalText RegFnt ChpCol2" >
Please let me know if something that I wrote here is inaccurate, so I can fix it.
</div>





<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->


<a name="Issues"/>

<div class="ChapterText RegFnt ChpCol1" >
Issues and open items
</div>

<div class="NormalText RegFnt ChpCol1" >
The code works fine for me but I didn't test everything and I might have missed some things, so some bugs might exist.
</div>

<div class="NormalText RegFnt ChpCol1" >
Open items:
<ul class="ListLev1">
    <li class="ListSpace"> Is the "pointer policy" for named pointers good enough? Is a "synchronized shared pointer" needed? If so, how to do it given that synchronization is platform-specific? I guess an option is to provide an additional header file using Boost. A user wanting that policy, will have to include that header and to have Boost installed. </li>

    <li> Is the default pointer policy OK ("unsynchronized shared pointers")? Or would it be better to have "cloned" or "synchronized shared" as the default? </li>

    <li class="ListSpace"> Should <span class="InlineCode">Functor.h</span> be split into more files, allowing only needed features to be included? (to improve compilation times, if they prove too long) </li>

    <li class="ListSpace"> If you want to use <span class="InlineCode">mkF</span> with overloaded functions a quite strange-looking cast has to be applied. Let's take for example the standard math function <span class="InlineCode">std::sin</span>), for which we want to call <span class="InlineCode">mkF</span> for the <span class="InlineCode">float</span> version: <span class="InlineCode">mkF((float (*)(float))&amp;std::sin)</span>. If this situation occurs often enough, maybe some <span class="InlineCode">typedef</span>s should be defined: <span class="InlineCode">typedef float (*FloatFun)(float);</span>. Then you get something that looks arguably better: <span class="InlineCode">mkF((FloatFun)&amp;std::sin)</span>. </li>

    <li class="ListSpace"> Are the predefined functors enough? Does anybody need an "advanced topics" page, to document the programming techniques that I used and to explain how to create your own functors to interact well with the predefined ones? </li>

    <li class="ListSpace"> Is it possible to get rid of the virtual function call used by named functors? If so, at what cost? Is this a good idea? </li>

    <li class="ListSpace"> Are there still some things too cumbersome to do? For this I'd really like some feedback, describing situations that should be easy / easier / possible to approach with functors in general but where QuickFunctor does a bad job. </li>

    <li class="ListSpace"> Should I make most constructors explicit? Probably not; the risk of allowing unwanted implicit conversions seems too low. </li>

    <li class="ListSpace"> Should macro shortcuts be included? (like <span class="InlineCode">ADDR1</span> for <span class="InlineCode">addr&lt;1&gt;()</span>, ...) </li>

    <li class="ListSpace"> It may be confusing that <span class="InlineCode">deref()</span> dereferences the result while <span class="InlineCode">deref&lt;1&gt;()</span> dereferences a parameter. Trying to use the wrong one will very likely generate a compiler error, so it's not such a big issue; but maybe a name change would be better. </li>

    <li class="ListSpace"> In previous versions, <span class="InlineCode">operator*(f)</span> on functors used to be a shortcut for <span class="InlineCode">comp&lt;1&gt;(f)</span>. Should that be enabled again? That would make some expressions not work, but it's quite natural to represent composition by "*". </li>
</ul>
</div>

<!--
<span class="InlineCode">a</span>
-->

<div class="NormalText RegFnt ChpCol1" >
The efficiency and compiler optimization areas need more looking at. From my point of view I think the compiler can make a lot of optimizations and in many cases what is a function calling another calling another can be translated into comparing two CPU registers. However, I'll have to look more into what optimizations are allowed by the standard and what optimizations are actually performed by real-world compilers. That might lead to changes in the internal structure of the library, but most likely not to interface changes.
</div>

<div class="NormalText RegFnt ChpCol1" >
To some extent QuickFunctor can be used to replace lambda functions, but what it can achieve from this point of view is rather limited, and language support for lambda functions would still be nice to have in the next standard. At some point I scribbled on a piece of paper something that seemed to allow loops and tests inside an expression used to create a functor, but I thought it just looked too weird. An important thing that was missing was "local variables", anyway. After releasing QuickFunctor I took a closer look at Boost's Lambda library and I noticed that what I had in mind was something similar to "if_then(condition, then_part), if_then_else(condition, then_part, else_part), if_then_else_return(condition, then_part, else_part), while_loop(condition, body), ..." from Boost.
</div>

<div class="NormalText RegFnt ChpCol1" >
For now I think I'd rather keep it simple and not provide such a thing, even though it looks cool. If you actually need this functionality you can just ignore QuickFunctor and revert to creating your own functor class with a good old <span class="InlineCode">operator()</span> with all the loops and tests you need inside it. Or perhaps a <b>better</b> approach is to just create a new function (instead of a whole new global class) with those loops, and call <span class="InlineCode">mkF()</span> for that function. This has the advantage that you don't need to create an external class (you know that you can declare classes inside functions but you can't pass them as template parameters, don't you?), so the code will be shorter.
</div>




<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->


<a name="OtherNotes"/>

<div class="ChapterText RegFnt ChpCol2" >
Other notes
</div>

<div class="NormalText RegFnt ChpCol2" >
The version included in the downloaded package handles functors with up to 3 parameters, but that can go up indefinitely <span class="Hlt">if you generate your own files</span> for some other maximum number of parameters (so long as the compiler can handle them). The maximum number of parameters that was tested (with an older version) was 9, which went OK, but made the compiler work a lot. The limit of 3 seemed reasonable for what I normally do, but feedback from other users might make me change it. To generate other files, just compile and run the file <span class="FileName">generator/FctGenerator.cpp</span>. Its first argument is the maximum number of arguments for functors and the second argument is the directory where the files <span class="FileName">Functor.h</span> and <span class="FileName">FunctorExpressions.h</span> should go. You must end the directory name with the path separator of your OS ("\" on Windows and "/" on most other systems). The code of <span class="FileName">FctGenerator.cpp</span> is a complete mess, but it should work. It's only been tested on GCC 4.1 on 64-bit Linux, but it doesn't contain template tricks so I expect it to work on most other systems too. Replace the old files with the generated ones and your version should be now able to handle your new maximum number of functor parameters.
</div>

<div class="NormalText RegFnt ChpCol2" >
The main test file is <span class="FileName">main_tests/FunctorTst.cpp</span>. The files located in <span class="FileName">other_tests</span> are other various tests, which more or less resemble those in <span class="FileName">FunctorTst.cpp</span>. They are provided for 2 purposes: one is to give additional usage examples and the other is to help determine if things didn't break after some changes were made to the library (they should still compile). Also, they contain some comments about why some things are in some way or another and indicate possible future directions.
</div>



<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->


<a name="Status"/>

<div class="ChapterText RegFnt ChpCol1" >
Project status
</div>

<div class="NormalText RegFnt ChpCol1" >
Beta, I guess. Or is it pre-alpha? While I believe that the code quality itself is pretty good and I don't envision any revolutionary changes or significant additions (or even bug fixes), names might change, obscure features might be dropped (permutations) or others might be added. However, I'm quite confident that porting a program written with the current version to new versions will require little change besides some Search&amp;Replace. I would normally keep the current names, but somebody might present strong reasons for name changes and only in that case there will actually be changes. Another thing is that maybe some more operations would be really useful but I didn't need them so far; so new operations may be added, but that shouldn't impact existing code.
</div>

<div class="NormalText RegFnt ChpCol1" >
I usually find very few bugs in the code that I considered I was roughly done with (even if I did not extensively check it / test it), but chances are that there are some bugs in QuickFunctor. And then there are the usual disagreements about code that does what it says but it should really say and do something else (or so some would think). And then there's also the chance that a last-minute small change that should have a very localized impact actually breaks more things. But at least the results of running the test files look good, so it's unlikely that such thing happened.
</div>





<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->

<a name="ReleaseHistory"/>

<div class="ChapterText RegFnt ChpCol2" >
Release history
</div>

<div class="NormalText RegFnt ChpCol2" >
A list of releases can be found in <a href="History.txt">this file</a>.
</div>




<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->
<!-- ========================================================================================================== -->

<a name="Support"/>

<div class="ChapterText RegFnt ChpCol1" >
Contact and support
</div>


<div class="NormalText RegFnt ChpCol1" >
If you think you found a bug or a design issue, please let me know. Or if you have some suggestions or comments. The address is <span class="Hlt">ciobi [at] inbox.com</span>. I started to get a lot of spam there, so to make sure that I don't delete a message by mistake, I would recommend using a subject line starting with "====================" or something like this, to make it stand out from the spam (usually the mail from unknown addresses goes to the "spam" folder).<br/>
</div>

<div class="NormalText RegFnt ChpCol1" >
You are also encouraged to use the <a href="http://sourceforge.net/forum/?group_id=203477">SourceForge forums</a>.
</div>


<div class="NormalText RegFnt ChpCol1" >
I also created a <a href="http://quickfunctor.blogspot.com/">QuickFunctor blog</a>. Initially it was intended for comments from users who wanted to post anonymous, because I thought that was not possible on SourceForge. After I figured out how to enable anonymous posting on SourceForge, I thought I should remove the blog, but then I changed my mind and I'm going to keep it for a while, to post there any news that I might have if they don't warrant a new release.
</div>


<div class="NormalText RegFnt ChpCol1" >
<br/>
Have fun,<br/>
<span class="NormalText RegFnt ChpCol1" style="padding-left:30px">Ciobi</span>
</div>



</body>
</html>
